# backend/app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_recycle=300,
    echo=settings.DEBUG
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    """Database dependency for FastAPI"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# backend/app/core/config.py
from pydantic_settings import BaseSettings
from typing import Optional
import secrets

class Settings(BaseSettings):
    PROJECT_NAME: str = "Pier 11 Marina Interactive Map"
    VERSION: str = "2.0.0"
    API_V1_STR: str = "/api/v1"
    
    # Database
    DATABASE_URL: str = "postgresql://pier11:password@localhost/pier11_marina"
    
    # Security
    SECRET_KEY: str = secrets.token_urlsafe(32)
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 30  # 30 days
    
    # CORS
    BACKEND_CORS_ORIGINS: list[str] = ["http://localhost:3000", "http://localhost:5173"]
    
    # Environment
    DEBUG: bool = False
    TESTING: bool = False
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()


# backend/app/models/__init__.py
from .user import User
from .map import Map
from .boat_listing import BoatListing
from .boat_position import BoatPosition

__all__ = ["User", "Map", "BoatListing", "BoatPosition"]


# backend/app/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum
from ..core.database import Base

class UserRole(str, enum.Enum):
    ADMIN = "admin"
    STAFF = "staff"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(Enum(UserRole), default=UserRole.STAFF, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    def __repr__(self):
        return f"<User(email='{self.email}', role='{self.role}')>"


# backend/app/models/map.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class Map(Base):
    __tablename__ = "maps"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)
    description = Column(Text)
    image_path = Column(String(255), nullable=False)
    image_width = Column(Integer, nullable=False, default=794)
    image_height = Column(Integer, nullable=False, default=1123)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    boat_positions = relationship("BoatPosition", back_populates="map", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Map(name='{self.name}', active={self.is_active})>"


# backend/app/models/boat_listing.py
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class BoatListing(Base):
    __tablename__ = "boat_listings"
    
    id = Column(Integer, primary_key=True, index=True)
    index = Column(Integer, unique=True, nullable=False, index=True)
    name = Column(String(100))
    customer_name = Column(String(100), nullable=False, index=True)
    size = Column(String(50))  # e.g., "35 ft"
    make_model = Column(String(100))
    vehicle_type = Column(String(50))  # boat, trailer, jetski, etc.
    section = Column(String(10))  # A, B, C, D, E, F
    notes = Column(Text)
    is_mapped = Column(Boolean, default=False, nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Foreign key to boat position (nullable for unmapped boats)
    position_id = Column(Integer, ForeignKey("boat_positions.id"), nullable=True, unique=True)
    
    # Relationships
    position = relationship("BoatPosition", back_populates="boat_listing", cascade="all, delete-orphan", single_parent=True)
    
    def __repr__(self):
        return f"<BoatListing(index={self.index}, name='{self.name}', customer='{self.customer_name}')>"


# backend/app/models/boat_position.py
from sqlalchemy import Column, Integer, Float, String, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class BoatPosition(Base):
    __tablename__ = "boat_positions"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # Map relationship
    map_id = Column(Integer, ForeignKey("maps.id"), nullable=False, index=True)
    
    # Canvas coordinates and dimensions
    x = Column(Float, nullable=False, default=200.0)
    y = Column(Float, nullable=False, default=200.0)
    width = Column(Float, nullable=False, default=100.0)
    height = Column(Float, nullable=False, default=50.0)
    rotation = Column(Float, nullable=False, default=0.0)  # in degrees
    
    # Visual properties
    color = Column(String(50), nullable=False, default="blue")
    stroke_color = Column(String(50), nullable=False, default="black")
    stroke_width = Column(Float, nullable=False, default=1.0)
    
    # Metadata
    is_visible = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    map = relationship("Map", back_populates="boat_positions")
    boat_listing = relationship("BoatListing", back_populates="position", uselist=False)
    
    def __repr__(self):
        return f"<BoatPosition(id={self.id}, x={self.x}, y={self.y}, map_id={self.map_id})>"


# backend/app/core/exceptions.py
from fastapi import HTTPException, status

class BaseCustomException(HTTPException):
    def __init__(self, detail: str = None, headers: dict = None):
        super().__init__(
            status_code=self.status_code,
            detail=detail or self.detail,
            headers=headers
        )

class NotFoundError(BaseCustomException):
    status_code = status.HTTP_404_NOT_FOUND
    detail = "Resource not found"

class ValidationError(BaseCustomException):
    status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
    detail = "Validation error"

class DuplicateError(BaseCustomException):
    status_code = status.HTTP_409_CONFLICT
    detail = "Resource already exists"

class UnauthorizedError(BaseCustomException):
    status_code = status.HTTP_401_UNAUTHORIZED
    detail = "Authentication required"

class ForbiddenError(BaseCustomException):
    status_code = status.HTTP_403_FORBIDDEN
    detail = "Insufficient permissions"


# backend/app/core/security.py
from datetime import datetime, timedelta
from typing import Any, Union
from passlib.context import CryptContext
from jose import JWTError, jwt
from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = "HS256"

def create_access_token(
    subject: Union[str, Any], expires_delta: timedelta = None
) -> str:
    """Create JWT access token"""
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Union[str, None]:
    """Verify JWT token and return subject"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
        token_subject: str = payload.get("sub")
        return token_subject
    except JWTError:
        return None

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)