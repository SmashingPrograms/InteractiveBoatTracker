# aic.txt
# backend/app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_recycle=300,
    echo=settings.DEBUG
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    """Database dependency for FastAPI"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# backend/app/core/config.py
from pydantic_settings import BaseSettings
from typing import Optional
import secrets

class Settings(BaseSettings):
    PROJECT_NAME: str = "Pier 11 Marina Interactive Map"
    VERSION: str = "2.0.0"
    API_V1_STR: str = "/api/v1"
    
    # Database
    DATABASE_URL: str = "postgresql://pier11:password@localhost/pier11_marina"
    
    # Security
    SECRET_KEY: str = secrets.token_urlsafe(32)
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 30  # 30 days
    
    # CORS
    BACKEND_CORS_ORIGINS: list[str] = ["http://localhost:3000", "http://localhost:5173"]
    
    # Environment
    DEBUG: bool = False
    TESTING: bool = False
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()


# backend/app/models/__init__.py
from .user import User
from .map import Map
from .boat_listing import BoatListing
from .boat_position import BoatPosition

__all__ = ["User", "Map", "BoatListing", "BoatPosition"]


# backend/app/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum
from ..core.database import Base

class UserRole(str, enum.Enum):
    ADMIN = "admin"
    STAFF = "staff"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(Enum(UserRole), default=UserRole.STAFF, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    def __repr__(self):
        return f"<User(email='{self.email}', role='{self.role}')>"


# backend/app/models/map.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class Map(Base):
    __tablename__ = "maps"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)
    description = Column(Text)
    image_path = Column(String(255), nullable=False)
    image_width = Column(Integer, nullable=False, default=794)
    image_height = Column(Integer, nullable=False, default=1123)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    boat_positions = relationship("BoatPosition", back_populates="map", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Map(name='{self.name}', active={self.is_active})>"


# backend/app/models/boat_listing.py
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class BoatListing(Base):
    __tablename__ = "boat_listings"
    
    id = Column(Integer, primary_key=True, index=True)
    index = Column(Integer, unique=True, nullable=False, index=True)
    name = Column(String(100))
    customer_name = Column(String(100), nullable=False, index=True)
    size = Column(String(50))  # e.g., "35 ft"
    make_model = Column(String(100))
    vehicle_type = Column(String(50))  # boat, trailer, jetski, etc.
    section = Column(String(10))  # A, B, C, D, E, F
    notes = Column(Text)
    is_mapped = Column(Boolean, default=False, nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Foreign key to boat position (nullable for unmapped boats)
    position_id = Column(Integer, ForeignKey("boat_positions.id"), nullable=True, unique=True)
    
    # Relationships
    position = relationship("BoatPosition", back_populates="boat_listing", cascade="all, delete-orphan", single_parent=True)
    
    def __repr__(self):
        return f"<BoatListing(index={self.index}, name='{self.name}', customer='{self.customer_name}')>"


# backend/app/models/boat_position.py
from sqlalchemy import Column, Integer, Float, String, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class BoatPosition(Base):
    __tablename__ = "boat_positions"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # Map relationship
    map_id = Column(Integer, ForeignKey("maps.id"), nullable=False, index=True)
    
    # Canvas coordinates and dimensions
    x = Column(Float, nullable=False, default=200.0)
    y = Column(Float, nullable=False, default=200.0)
    width = Column(Float, nullable=False, default=100.0)
    height = Column(Float, nullable=False, default=50.0)
    rotation = Column(Float, nullable=False, default=0.0)  # in degrees
    
    # Visual properties
    color = Column(String(50), nullable=False, default="blue")
    stroke_color = Column(String(50), nullable=False, default="black")
    stroke_width = Column(Float, nullable=False, default=1.0)
    
    # Metadata
    is_visible = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    map = relationship("Map", back_populates="boat_positions")
    boat_listing = relationship("BoatListing", back_populates="position", uselist=False)
    
    def __repr__(self):
        return f"<BoatPosition(id={self.id}, x={self.x}, y={self.y}, map_id={self.map_id})>"


# backend/app/core/exceptions.py
from fastapi import HTTPException, status

class BaseCustomException(HTTPException):
    def __init__(self, detail: str = None, headers: dict = None):
        super().__init__(
            status_code=self.status_code,
            detail=detail or self.detail,
            headers=headers
        )

class NotFoundError(BaseCustomException):
    status_code = status.HTTP_404_NOT_FOUND
    detail = "Resource not found"

class ValidationError(BaseCustomException):
    status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
    detail = "Validation error"

class DuplicateError(BaseCustomException):
    status_code = status.HTTP_409_CONFLICT
    detail = "Resource already exists"

class UnauthorizedError(BaseCustomException):
    status_code = status.HTTP_401_UNAUTHORIZED
    detail = "Authentication required"

class ForbiddenError(BaseCustomException):
    status_code = status.HTTP_403_FORBIDDEN
    detail = "Insufficient permissions"


# backend/app/core/security.py
from datetime import datetime, timedelta
from typing import Any, Union
from passlib.context import CryptContext
from jose import JWTError, jwt
from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = "HS256"

def create_access_token(
    subject: Union[str, Any], expires_delta: timedelta = None
) -> str:
    """Create JWT access token"""
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Union[str, None]:
    """Verify JWT token and return subject"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
        token_subject: str = payload.get("sub")
        return token_subject
    except JWTError:
        return None

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)

# README.md
# Pier 11 Marina Interactive Map v2.0

## Overview

A professional-grade interactive boat management system for marina operations. This application provides visual mapping, comprehensive boat tracking, and real-time updates for marina staff and administrators.

## Business Context

Pier 11 Marina is a family-owned boat storage and service facility in Chicago, operating since 1983. This system replaces manual paper-based tracking with a visual, searchable, real-time boat management interface that handles 200+ boats across 6 acres.

## Key Features

- **Interactive Visual Map**: Drag-and-drop boat positioning on actual marina layout
- **Comprehensive Boat Management**: Full CRUD operations with search and filtering
- **Multi-Map Architecture**: Support for multiple marina properties (Pier 11, Paoli Storage)
- **Real-time Updates**: Automatic synchronization between map and data
- **Responsive Design**: Professional UI with collapsible sidebar
- **Role-based Authentication**: Admin and staff access levels
- **Comprehensive Testing**: Unit, integration, and E2E test coverage

## Technology Stack

### Backend
- **FastAPI**: Modern Python web framework
- **SQLAlchemy**: ORM with PostgreSQL database
- **Pydantic**: Data validation and serialization
- **JWT**: Authentication and authorization
- **Pytest**: Testing framework
- **Alembic**: Database migrations

### Frontend
- **React 18**: Modern React with hooks
- **Vite**: Fast build tool and dev server
- **TypeScript**: Type safety throughout
- **React Konva**: Interactive canvas for map manipulation
- **TanStack Query**: Server state management
- **Zustand**: Client state management
- **Vitest**: Unit testing framework
- **Testing Library**: Component testing
- **Playwright**: End-to-end testing

## Project Structure

```
pier11-marina-v2/
├── README.md
├── docker-compose.yml
├── .env.example
├── .gitignore
├── 
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── core/
│   │   │   ├── __init__.py
│   │   │   ├── config.py
│   │   │   ├── database.py
│   │   │   ├── security.py
│   │   │   └── exceptions.py
│   │   ├── models/
│   │   │   ├── __init__.py
│   │   │   ├── user.py
│   │   │   ├── map.py
│   │   │   ├── boat_listing.py
│   │   │   └── boat_position.py
│   │   ├── schemas/
│   │   │   ├── __init__.py
│   │   │   ├── user.py
│   │   │   ├── map.py
│   │   │   ├── boat_listing.py
│   │   │   └── boat_position.py
│   │   ├── api/
│   │   │   ├── __init__.py
│   │   │   ├── deps.py
│   │   │   └── v1/
│   │   │       ├── __init__.py
│   │   │       ├── auth.py
│   │   │       ├── maps.py
│   │   │       ├── boats.py
│   │   │       └── positions.py
│   │   ├── services/
│   │   │   ├── __init__.py
│   │   │   ├── auth.py
│   │   │   ├── boat.py
│   │   │   └── map.py
│   │   └── utils/
│   │       ├── __init__.py
│   │       ├── logger.py
│   │       └── validators.py
│   ├── tests/
│   │   ├── __init__.py
│   │   ├── conftest.py
│   │   ├── test_models/
│   │   ├── test_api/
│   │   ├── test_services/
│   │   └── test_utils/
│   ├── alembic/
│   │   ├── versions/
│   │   └── alembic.ini
│   ├── requirements.txt
│   ├── Dockerfile
│   └── pytest.ini
│
├── frontend/
│   ├── public/
│   │   ├── index.html
│   │   └── assets/
│   │       └── maps/
│   │           └── pier11_marina.jpg
│   ├── src/
│   │   ├── main.tsx
│   │   ├── App.tsx
│   │   ├── components/
│   │   │   ├── common/
│   │   │   │   ├── Button.tsx
│   │   │   │   ├── Modal.tsx
│   │   │   │   ├── ConfirmDialog.tsx
│   │   │   │   ├── LoadingSpinner.tsx
│   │   │   │   └── ErrorBoundary.tsx
│   │   │   ├── layout/
│   │   │   │   ├── Navbar.tsx
│   │   │   │   ├── Sidebar.tsx
│   │   │   │   └── Layout.tsx
│   │   │   ├── map/
│   │   │   │   ├── MapCanvas.tsx
│   │   │   │   ├── BoatObject.tsx
│   │   │   │   ├── MapControls.tsx
│   │   │   │   └── MapToolbar.tsx
│   │   │   ├── boat/
│   │   │   │   ├── BoatList.tsx
│   │   │   │   ├── BoatCard.tsx
│   │   │   │   ├── BoatForm.tsx
│   │   │   │   ├── BoatSearch.tsx
│   │   │   │   └── BoatDetails.tsx
│   │   │   └── auth/
│   │   │       ├── LoginForm.tsx
│   │   │       └── ProtectedRoute.tsx
│   │   ├── hooks/
│   │   │   ├── useAuth.ts
│   │   │   ├── useBoats.ts
│   │   │   ├── useMaps.ts
│   │   │   └── useDebounce.ts
│   │   ├── stores/
│   │   │   ├── authStore.ts
│   │   │   ├── mapStore.ts
│   │   │   └── uiStore.ts
│   │   ├── services/
│   │   │   ├── api.ts
│   │   │   ├── auth.ts
│   │   │   ├── boats.ts
│   │   │   └── maps.ts
│   │   ├── types/
│   │   │   ├── api.ts
│   │   │   ├── boat.ts
│   │   │   ├── map.ts
│   │   │   └── user.ts
│   │   ├── utils/
│   │   │   ├── constants.ts
│   │   │   ├── formatters.ts
│   │   │   ├── validators.ts
│   │   │   └── storage.ts
│   │   └── styles/
│   │       ├── globals.css
│   │       ├── components.css
│   │       └── utilities.css
│   ├── tests/
│   │   ├── setup.ts
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── services/
│   │   ├── utils/
│   │   └── e2e/
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── tailwind.config.js
│   ├── vitest.config.ts
│   ├── playwright.config.ts
│   └── Dockerfile
│
└── docs/
    ├── api.md
    ├── deployment.md
    ├── development.md
    └── user-guide.md
```

## Database Schema

### Maps
- Support for multiple marina properties
- Image upload and management
- Active/inactive status

### Boat Listings
- Complete boat information (size, make, model, customer, etc.)
- Proper foreign key relationships
- Index-based tracking system

### Boat Positions
- Canvas coordinates and dimensions
- Visual properties (color, rotation)
- Relationship to specific maps

### Users & Authentication
- Role-based access (admin, staff)
- JWT-based authentication
- Session management

## Development Setup

### Prerequisites
- Node.js 18+
- Python 3.11+
- PostgreSQL 14+
- Docker & Docker Compose

### Database Setup

1. **Install PostgreSQL** (if not already installed):
   ```bash
   brew install postgresql@14
   brew services start postgresql@14
   ```

2. **Create Database User and Database**:
   ```bash
   # Connect to PostgreSQL
   psql postgres
   
   # Inside PostgreSQL prompt, create user and database:
   CREATE USER pier11 WITH PASSWORD 'password';
   CREATE DATABASE pier11_marina OWNER pier11;
   GRANT ALL PRIVILEGES ON DATABASE pier11_marina TO pier11;
   
   # Exit PostgreSQL
   \q
   ```

3. **Verify Connection**:
   ```bash
   psql -U pier11 -d pier11_marina -h localhost
   ```

### Quick Start
```bash
# Clone repository
git clone <repository-url>
cd pier11-marina-v2

# Start with Docker Compose
docker-compose up -d

# Or manual setup:

# Backend setup
cd backend
pip install -r requirements.txt

# Initialize Alembic (if not already done)
alembic init alembic

# Edit alembic.ini to set database URL:
# sqlalchemy.url = postgresql://pier11:password@localhost/pier11_marina

# Create and apply migrations
alembic revision --autogenerate -m "Initial migration"
alembic upgrade head

# Start the backend server
uvicorn app.main:app --reload

# Frontend setup (in new terminal)
cd frontend
npm install
npm run dev
```

### Environment Variables
Copy `.env.example` to `.env` and configure:
```env
DATABASE_URL=postgresql://pier11:password@localhost/pier11_marina
SECRET_KEY=your-secret-key
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=30
```

### Environment Variables
Copy `.env.example` to `.env` and configure:
```env
DATABASE_URL=postgresql://pier11:password@localhost/pier11_marina
SECRET_KEY=your-secret-key
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=30
```

**PostgreSQL won't start:**
```bash
# Check service status
brew services list | grep postgresql

# Restart PostgreSQL
brew services stop postgresql@14
brew services start postgresql@14

# Check logs
tail -f /usr/local/var/log/postgresql@14.log
```

**Role/Database doesn't exist:**
```bash
# Recreate user and database
psql postgres
CREATE USER pier11 WITH PASSWORD 'password';
CREATE DATABASE pier11_marina OWNER pier11;
GRANT ALL PRIVILEGES ON DATABASE pier11_marina TO pier11;
```

**Connection refused:**
- Ensure PostgreSQL is running: `brew services start postgresql@14`
- Check if something else is using port 5432: `lsof -i :5432`

## Testing

### Backend Testing
```bash
cd backend
pytest --cov=app --cov-report=html
```

### Frontend Testing
```bash
cd frontend
npm run test:unit          # Vitest unit tests
npm run test:integration   # Testing Library
npm run test:e2e           # Playwright E2E
```

## API Documentation

FastAPI provides automatic API documentation:
- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`

## Key Improvements from v1

### Architecture
- ✅ Proper database relationships with foreign keys
- ✅ Multi-map support architecture
- ✅ Separation of concerns (services, models, schemas)
- ✅ Type safety throughout with TypeScript

### User Experience
- ✅ Responsive design with collapsible sidebar
- ✅ Professional UI components
- ✅ Real-time updates without page refresh
- ✅ Comprehensive error handling and user feedback

### Code Quality
- ✅ Senior-level code organization
- ✅ Comprehensive test coverage
- ✅ Proper error handling and logging
- ✅ Code documentation and type hints

### Performance
- ✅ Optimized database queries
- ✅ Efficient state management
- ✅ Canvas rendering optimizations
- ✅ Lazy loading and pagination

## Deployment

### Production Deployment
```bash
# Build containers
docker-compose -f docker-compose.prod.yml build

# Deploy
docker-compose -f docker-compose.prod.yml up -d
```

### Environment-specific Configuration
- Development: Local SQLite/PostgreSQL
- Staging: Cloud database with test data
- Production: Full PostgreSQL with backups

## Contributing

### Code Standards
- Follow TypeScript/Python type hints
- Write tests for all new features
- Use conventional commit messages
- Maintain test coverage above 90%

### Pull Request Process
1. Create feature branch from `main`
2. Write comprehensive tests
3. Ensure all tests pass
4. Update documentation
5. Request code review

## License

Proprietary - Pier 11 Marina

## Support

For technical issues or feature requests:
- Create GitHub issue
- Contact development team
- Check documentation in `/docs`

---

## Next Phase: v3.0 Features

Planned for future releases:
- Dynamic scale component
- Advanced boat analytics
- Customer portal access
- Mobile app companion
- Integration with marina POS systems
- Automated reporting and insights

# frontend/tsconfig.node.json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


<!-- frontend/index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// frontend/tailwind.config.js
// frontend/tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#eff6ff',
          500: '#3b82f6',
          600: '#2563eb',
          700: '#1d4ed8',
        },
      },
      animation: {
        'fade-in': 'fadeIn 0.5s ease-in-out',
        'slide-in-right': 'slideInRight 0.3s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideInRight: {
          '0%': { transform: 'translateX(100%)' },
          '100%': { transform: 'translateX(0)' },
        },
      },
    },
  },
  plugins: [],
}



# frontend/tsconfig.app.json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


# frontend/README.md
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```


# frontend/tsconfig.json
// frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}



// frontend/playwright.config.ts
// frontend/playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './src/tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
  ],

  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
});

// frontend/eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])


// frontend/vite.config.ts
// frontend/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 5173,
    host: true,
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          konva: ['konva', 'react-konva'],
          query: ['@tanstack/react-query'],
        },
      },
    },
  },
});



// frontend/vitest.config.ts
// frontend/vitest.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/tests/setup.ts'],
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});



// frontend/src/App.tsx
// frontend/src/App.tsx (Updated with routing)
import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { ErrorBoundary } from './components/common/ErrorBoundary';
import { ProtectedRoute } from './components/auth/ProtectedRoute';
import { Layout } from './components/layout/Layout';
import { MapCanvas } from './components/map/MapCanvas';
import { MapManagementPage } from './components/map/MapManagementPage';
import { BoatForm } from './components/boat/BoatForm';
import { ConfirmDialog } from './components/common/ConfirmDialog';
import { useUIStore } from './stores/uiStore';
import './styles/globals.css';

// Create a client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 1,
    },
  },
});

const AppContent: React.FC = () => {
  const { showConfirmDialog, confirmDialogConfig, hideConfirm, currentPage } = useUIStore();

  const renderCurrentPage = () => {
    switch (currentPage) {
      case 'maps':
        return <MapManagementPage />;
      case 'map':
      default:
        return <MapCanvas />;
    }
  };

  return (
    <Layout>
      {renderCurrentPage()}
      
      {/* Global modals */}
      <BoatForm />
      
      {showConfirmDialog && confirmDialogConfig && (
        <ConfirmDialog
          isOpen={showConfirmDialog}
          title={confirmDialogConfig.title}
          message={confirmDialogConfig.message}
          onConfirm={confirmDialogConfig.onConfirm}
          onCancel={confirmDialogConfig.onCancel || hideConfirm}
          variant="danger"
        />
      )}
    </Layout>
  );
};

export const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <ProtectedRoute>
          <AppContent />
        </ProtectedRoute>
        <ReactQueryDevtools initialIsOpen={false} />
      </QueryClientProvider>
    </ErrorBoundary>
  );
};

export default App;

// frontend/src/main.tsx
// frontend/src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



<!-- frontend/src/App.css -->
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


<!-- frontend/src/index.css -->
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}


// frontend/src/vite-env.d.ts
/// <reference types="vite/client" />


// frontend/src/types/boat.ts
// frontend/src/types/boat.ts
export interface BoatListing {
  id: number;
  index: number;
  name?: string;
  customer_name: string;
  size?: string;
  make_model?: string;
  vehicle_type?: string;
  section?: string;
  notes?: string;
  is_mapped: boolean;
  position_id?: number;
  created_at: string;
  updated_at?: string;
}

export interface BoatListingCreate {
  index: number;
  name?: string;
  customer_name: string;
  size?: string;
  make_model?: string;
  vehicle_type?: string;
  section?: string;
  notes?: string;
}

export interface BoatListingUpdate {
  index?: number;
  name?: string;
  customer_name?: string;
  size?: string;
  make_model?: string;
  vehicle_type?: string;
  section?: string;
  notes?: string;
}

export interface BoatPosition {
  id: number;
  map_id: number;
  x: number;
  y: number;
  width: number;
  height: number;
  rotation: number;
  color: string;
  stroke_color: string;
  stroke_width: number;
  is_visible: boolean;
  created_at: string;
  updated_at?: string;
}

export interface BoatPositionCreate {
  map_id: number;
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  rotation?: number;
  color?: string;
  stroke_color?: string;
  stroke_width?: number;
  is_visible?: boolean;
}

export interface BoatPositionUpdate {
  x?: number;
  y?: number;
  width?: number;
  height?: number;
  rotation?: number;
  color?: string;
  stroke_color?: string;
  stroke_width?: number;
  is_visible?: boolean;
}

export interface BoatWithPosition {
  boat?: BoatListing;
  position: BoatPosition;
}

export interface BoatSearchParams extends SearchParams {
  mapped_only?: boolean;
  section?: string;
}



// frontend/src/types/api.ts
// frontend/src/types/api.ts
export interface ApiResponse<T> {
  data: T;
  message?: string;
}

export interface ApiError {
  detail: string;
  status_code: number;
}

export interface PaginationParams {
  skip?: number;
  limit?: number;
}

export interface SearchParams extends PaginationParams {
  search?: string;
}



// frontend/src/types/map.ts
// frontend/src/types/map.ts
export interface Map {
  id: number;
  name: string;
  description?: string;
  image_path: string;
  image_width: number;
  image_height: number;
  is_active: boolean;
  created_at: string;
  updated_at?: string;
  boat_count?: number;
}

export interface MapCreate {
  name: string;
  description?: string;
  image_path: string;
  image_width?: number;
  image_height?: number;
  is_active?: boolean;
}

export interface MapUpdate {
  name?: string;
  description?: string;
  image_path?: string;
  image_width?: number;
  image_height?: number;
  is_active?: boolean;
}

export interface MapWithBoats {
  map: Map;
  boats: BoatWithPosition[];
}



// frontend/src/types/user.ts
// frontend/src/types/user.ts
export enum UserRole {
  ADMIN = 'admin',
  STAFF = 'staff'
}

export interface User {
  id: number;
  email: string;
  full_name: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
  updated_at?: string;
}

export interface UserCreate {
  email: string;
  full_name: string;
  password: string;
  role?: UserRole;
  is_active?: boolean;
}

export interface UserUpdate {
  email?: string;
  full_name?: string;
  role?: UserRole;
  is_active?: boolean;
  password?: string;
}

export interface LoginCredentials {
  username: string;
  password: string;
}

export interface AuthToken {
  access_token: string;
  token_type: string;
}



// frontend/src/tests/setup.ts
// frontend/src/tests/setup.ts
import '@testing-library/jest-dom';
import { vi } from 'vitest';

// Mock window.URL.createObjectURL
Object.defineProperty(window, 'URL', {
  value: {
    createObjectURL: vi.fn(() => 'mocked-url'),
    revokeObjectURL: vi.fn(),
  },
  writable: true,
});

// Mock window.history
Object.defineProperty(window, 'history', {
  value: {
    back: vi.fn(),
    forward: vi.fn(),
    go: vi.fn(),
    pushState: vi.fn(),
    replaceState: vi.fn(),
  },
  writable: true,
});

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock IntersectionObserver  
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Suppress console warnings in tests
const originalWarn = console.warn;
beforeAll(() => {
  console.warn = (...args) => {
    if (typeof args[0] === 'string' && args[0].includes('React Router')) {
      return;
    }
    originalWarn(...args);
  };
});

afterAll(() => {
  console.warn = originalWarn;
});

// frontend/src/tests/stores/uiStore.test.tsx
// frontend/src/tests/stores/uiStore.test.tsx
import { describe, it, expect } from 'vitest';
import { act, renderHook } from '@testing-library/react';
import { useUIStore } from '../../stores/uiStore';

describe('useUIStore', () => {
  it('initializes with correct default values', () => {
    const { result } = renderHook(() => useUIStore());
    
    expect(result.current.sidebarOpen).toBe(true);
    expect(result.current.selectedPositionId).toBeNull();
    expect(result.current.showBoatForm).toBe(false);
    expect(result.current.showMapForm).toBe(false);
    expect(result.current.currentPage).toBe('map');
  });

  it('toggles sidebar correctly', () => {
    const { result } = renderHook(() => useUIStore());
    
    act(() => {
      result.current.toggleSidebar();
    });
    
    expect(result.current.sidebarOpen).toBe(false);
    
    act(() => {
      result.current.toggleSidebar();
    });
    
    expect(result.current.sidebarOpen).toBe(true);
  });

  it('sets selected position', () => {
    const { result } = renderHook(() => useUIStore());
    
    act(() => {
      result.current.setSelectedPosition(123);
    });
    
    expect(result.current.selectedPositionId).toBe(123);
    
    act(() => {
      result.current.setSelectedPosition(null);
    });
    
    expect(result.current.selectedPositionId).toBeNull();
  });

  it('manages map form modal state', () => {
    const { result } = renderHook(() => useUIStore());
    
    act(() => {
      result.current.showMapFormModal();
    });
    
    expect(result.current.showMapForm).toBe(true);
    
    act(() => {
      result.current.hideMapFormModal();
    });
    
    expect(result.current.showMapForm).toBe(false);
  });

  it('manages page navigation', () => {
    const { result } = renderHook(() => useUIStore());
    
    act(() => {
      result.current.setCurrentPage('maps');
    });
    
    expect(result.current.currentPage).toBe('maps');
    
    act(() => {
      result.current.setCurrentPage('map');
    });
    
    expect(result.current.currentPage).toBe('map');
  });

  it('manages confirm dialog', () => {
    const { result } = renderHook(() => useUIStore());
    
    const mockConfig = {
      title: 'Test Title',
      message: 'Test message',
      onConfirm: () => {},
      onCancel: () => {},
    };
    
    act(() => {
      result.current.showConfirm(mockConfig);
    });
    
    expect(result.current.showConfirmDialog).toBe(true);
    expect(result.current.confirmDialogConfig).toEqual(mockConfig);
    
    act(() => {
      result.current.hideConfirm();
    });
    
    expect(result.current.showConfirmDialog).toBe(false);
    expect(result.current.confirmDialogConfig).toBeNull();
  });

  it('clamps map zoom correctly', () => {
    const { result } = renderHook(() => useUIStore());
    
    // Test upper bound
    act(() => {
      result.current.setMapZoom(5);
    });
    
    expect(result.current.mapZoom).toBe(3);
    
    // Test lower bound
    act(() => {
      result.current.setMapZoom(0.05);
    });
    
    expect(result.current.mapZoom).toBe(0.1);
    
    // Test normal value
    act(() => {
      result.current.setMapZoom(1.5);
    });
    
    expect(result.current.mapZoom).toBe(1.5);
  });
});




// frontend/src/tests/components/common/FileUpload.test.tsx
// frontend/src/tests/components/common/FileUpload.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { FileUpload } from '../../../components/common/FileUpload';

describe('FileUpload', () => {
  const mockOnFileSelect = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders upload area', () => {
    render(<FileUpload onFileSelect={mockOnFileSelect} />);
    
    expect(screen.getByText(/click to upload/i)).toBeInTheDocument();
    expect(screen.getByText(/drag and drop/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /choose file/i })).toBeInTheDocument();
  });

  it('accepts valid file types', async () => {
    const user = userEvent.setup();
    render(
      <FileUpload 
        onFileSelect={mockOnFileSelect}
        acceptedTypes={['image/jpeg', 'image/png']}
      />
    );
    
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
    const input = screen.getByRole('button').closest('div')?.querySelector('input[type="file"]');
    
    if (input) {
      await user.upload(input, file);
      expect(mockOnFileSelect).toHaveBeenCalledWith(file);
    }
  });

  it('rejects invalid file types', async () => {
    const user = userEvent.setup();
    render(
      <FileUpload 
        onFileSelect={mockOnFileSelect}
        acceptedTypes={['image/jpeg']}
      />
    );
    
    const file = new File(['test'], 'test.txt', { type: 'text/plain' });
    const input = screen.getByRole('button').closest('div')?.querySelector('input[type="file"]');
    
    if (input) {
      await user.upload(input, file);
      expect(mockOnFileSelect).not.toHaveBeenCalled();
      expect(screen.getByText(/file type text\/plain is not supported/i)).toBeInTheDocument();
    }
  });

  it('rejects files exceeding size limit', async () => {
    const user = userEvent.setup();
    const maxSize = 1024; // 1KB
    
    render(
      <FileUpload 
        onFileSelect={mockOnFileSelect}
        maxSize={maxSize}
      />
    );
    
    // Create file larger than limit
    const largeContent = 'x'.repeat(maxSize + 1);
    const file = new File([largeContent], 'large.jpg', { type: 'image/jpeg' });
    
    const input = screen.getByRole('button').closest('div')?.querySelector('input[type="file"]');
    
    if (input) {
      await user.upload(input, file);
      expect(mockOnFileSelect).not.toHaveBeenCalled();
      expect(screen.getByText(/file size must be less than/i)).toBeInTheDocument();
    }
  });

  it('handles drag and drop', async () => {
    render(<FileUpload onFileSelect={mockOnFileSelect} />);
    
    const dropZone = screen.getByText(/click to upload/i).closest('div');
    const file = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
    
    if (dropZone) {
      // Simulate drag over
      fireEvent.dragOver(dropZone);
      // Should add drag over styling classes
      
      // Simulate drop
      fireEvent.drop(dropZone, {
        dataTransfer: {
          files: [file],
        },
      });
      
      expect(mockOnFileSelect).toHaveBeenCalledWith(file);
    }
  });

  it('disables interaction when disabled', () => {
    render(<FileUpload onFileSelect={mockOnFileSelect} disabled />);
    
    const button = screen.getByRole('button', { name: /choose file/i });
    expect(button).toBeDisabled();
  });
});

// frontend/src/tests/components/map/MapForm.test.tsx
// frontend/src/tests/components/map/MapForm.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { MapForm } from '../../../components/map/MapForm';
import { useUIStore } from '../../../stores/uiStore';
import * as mapsHooks from '../../../hooks/useMaps';

// Mock the hooks
vi.mock('../../../hooks/useMaps');
vi.mock('../../../stores/uiStore');

const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

const renderWithProviders = (component: React.ReactElement) => {
  const queryClient = createTestQueryClient();
  return render(
    <QueryClientProvider client={queryClient}>
      {component}
    </QueryClientProvider>
  );
};

describe('MapForm', () => {
  const mockCreateMap = vi.fn();
  const mockUpdateMap = vi.fn();
  const mockHideModal = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    
    vi.mocked(useUIStore).mockReturnValue({
      showMapForm: true,
      hideMapFormModal: mockHideModal,
    } as any);

    vi.mocked(mapsHooks.useCreateMap).mockReturnValue({
      mutateAsync: mockCreateMap,
      isPending: false,
    } as any);

    vi.mocked(mapsHooks.useUpdateMap).mockReturnValue({
      mutateAsync: mockUpdateMap,
      isPending: false,
    } as any);
  });

  it('renders create form correctly', () => {
    renderWithProviders(<MapForm />);
    
    expect(screen.getByText('Add New Map')).toBeInTheDocument();
    expect(screen.getByLabelText(/map name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/description/i)).toBeInTheDocument();
    expect(screen.getByText(/marina layout image/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /create map/i })).toBeInTheDocument();
  });

  it('validates required fields', async () => {
    const user = userEvent.setup();
    renderWithProviders(<MapForm />);
    
    const submitButton = screen.getByRole('button', { name: /create map/i });
    await user.click(submitButton);
    
    expect(screen.getByText('Map name is required')).toBeInTheDocument();
    expect(screen.getByText('Map image is required')).toBeInTheDocument();
    expect(mockCreateMap).not.toHaveBeenCalled();
  });

  it('submits form with valid data', async () => {
    const user = userEvent.setup();
    mockCreateMap.mockResolvedValue({});
    
    renderWithProviders(<MapForm />);
    
    // Fill in form
    await user.type(screen.getByLabelText(/map name/i), 'Test Marina');
    await user.type(screen.getByLabelText(/description/i), 'Test description');
    await user.type(screen.getByLabelText(/width/i), '800');
    await user.type(screen.getByLabelText(/height/i), '600');
    
    // Mock file upload
    const fileInput = screen.getByRole('button', { name: /choose file/i }).closest('div')?.querySelector('input[type="file"]');
    const file = new File(['test'], 'test-map.jpg', { type: 'image/jpeg' });
    
    if (fileInput) {
      await user.upload(fileInput, file);
    }
    
    // Submit form
    await user.click(screen.getByRole('button', { name: /create map/i }));
    
    await waitFor(() => {
      expect(mockCreateMap).toHaveBeenCalledWith({
        name: 'Test Marina',
        description: 'Test description',
        image_path: 'test-map.jpg',
        image_width: 800,
        image_height: 600,
        is_active: true,
      });
    });
    
    expect(mockHideModal).toHaveBeenCalled();
  });

  it('validates image dimensions', async () => {
    const user = userEvent.setup();
    renderWithProviders(<MapForm />);
    
    await user.type(screen.getByLabelText(/map name/i), 'Test');
    await user.clear(screen.getByLabelText(/width/i));
    await user.type(screen.getByLabelText(/width/i), '0');
    
    await user.click(screen.getByRole('button', { name: /create map/i }));
    
    expect(screen.getByText('Width must be greater than 0')).toBeInTheDocument();
  });

  it('shows loading state during submission', async () => {
    const user = userEvent.setup();
    
    vi.mocked(mapsHooks.useCreateMap).mockReturnValue({
      mutateAsync: mockCreateMap,
      isPending: true,
    } as any);
    
    renderWithProviders(<MapForm />);
    
    expect(screen.getByRole('button', { name: /create map/i })).toBeDisabled();
    expect(screen.getByLabelText(/map name/i)).toBeDisabled();
  });
});

// frontend/src/tests/components/map/MapManagementPage.test.tsx
// frontend/src/tests/components/map/MapManagementPage.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { MapManagementPage } from '../../../components/map/MapManagementPage';
import * as mapsHooks from '../../../hooks/useMaps';
import { useAuth } from '../../../hooks/useAuth';
import { useUIStore } from '../../../stores/uiStore';

vi.mock('../../../hooks/useMaps');
vi.mock('../../../hooks/useAuth');
vi.mock('../../../stores/uiStore');

const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

const renderWithProviders = (component: React.ReactElement) => {
  const queryClient = createTestQueryClient();
  return render(
    <QueryClientProvider client={queryClient}>
      {component}
    </QueryClientProvider>
  );
};

describe('MapManagementPage', () => {
  const mockShowMapFormModal = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    
    vi.mocked(useAuth).mockReturnValue({
      isAdmin: true,
    } as any);
    
    vi.mocked(useUIStore).mockReturnValue({
      showMapFormModal: mockShowMapFormModal,
    } as any);
  });

  it('renders loading state', () => {
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: [],
      isLoading: true,
      error: null,
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    expect(screen.getByRole('status')).toBeInTheDocument(); // Loading spinner
  });

  it('renders error state', () => {
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: [],
      isLoading: false,
      error: new Error('Failed to load'),
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    expect(screen.getByText('Failed to load maps')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /retry/i })).toBeInTheDocument();
  });

  it('renders empty state for admin', () => {
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: [],
      isLoading: false,
      error: null,
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    expect(screen.getByText('No maps found')).toBeInTheDocument();
    expect(screen.getByText('Get started by creating your first marina map')).toBeInTheDocument();
    expect(screen.getByText('Create Your First Map')).toBeInTheDocument();
  });

  it('renders empty state for non-admin', () => {
    vi.mocked(useAuth).mockReturnValue({
      isAdmin: false,
    } as any);
    
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: [],
      isLoading: false,
      error: null,
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    expect(screen.getByText('No maps have been created yet')).toBeInTheDocument();
    expect(screen.queryByText('Create Your First Map')).not.toBeInTheDocument();
  });

  it('renders maps grid', () => {
    const mockMaps = [
      {
        id: 1,
        name: 'Marina 1',
        description: 'First marina',
        image_path: 'marina1.jpg',
        image_width: 800,
        image_height: 600,
        is_active: true,
        created_at: '2024-01-01T00:00:00Z',
        boat_count: 3,
      },
      {
        id: 2,
        name: 'Marina 2',
        description: 'Second marina',
        image_path: 'marina2.jpg',
        image_width: 1000,
        image_height: 800,
        is_active: true,
        created_at: '2024-01-02T00:00:00Z',
        boat_count: 7,
      },
    ];
    
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: mockMaps,
      isLoading: false,
      error: null,
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    expect(screen.getByText('Marina Maps')).toBeInTheDocument();
    expect(screen.getByText('Marina 1')).toBeInTheDocument();
    expect(screen.getByText('Marina 2')).toBeInTheDocument();
  });

  it('shows add button for admin', () => {
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: [],
      isLoading: false,
      error: null,
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    expect(screen.getByRole('button', { name: /add new map/i })).toBeInTheDocument();
  });

  it('hides add button for non-admin', () => {
    vi.mocked(useAuth).mockReturnValue({
      isAdmin: false,
    } as any);
    
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: [],
      isLoading: false,
      error: null,
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    expect(screen.queryByRole('button', { name: /add new map/i })).not.toBeInTheDocument();
  });

  it('opens map form modal', async () => {
    const user = userEvent.setup();
    
    vi.mocked(mapsHooks.useMaps).mockReturnValue({
      data: [],
      isLoading: false,
      error: null,
    } as any);
    
    renderWithProviders(<MapManagementPage />);
    
    await user.click(screen.getByRole('button', { name: /add new map/i }));
    
    expect(mockShowMapFormModal).toHaveBeenCalled();
  });
});

// frontend/src/tests/components/map/MapCard.test.tsx
// frontend/src/tests/components/map/MapCard.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { MapCard } from '../../../components/map/MapCard';
import { useMapStore } from '../../../stores/mapStore';
import { useUIStore } from '../../../stores/uiStore';
import { useAuth } from '../../../hooks/useAuth';
import { Map } from '../../../types/map';

vi.mock('../../../stores/mapStore');
vi.mock('../../../stores/uiStore');
vi.mock('../../../hooks/useAuth');
vi.mock('../../../hooks/useMaps');

const mockMap: Map = {
  id: 1,
  name: 'Test Marina',
  description: 'Test description',
  image_path: 'test-map.jpg',
  image_width: 800,
  image_height: 600,
  is_active: true,
  created_at: '2024-01-01T00:00:00Z',
  boat_count: 5,
};

describe('MapCard', () => {
  const mockSetCurrentMap = vi.fn();
  const mockShowConfirm = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    
    vi.mocked(useMapStore).mockReturnValue({
      selectedMapId: null,
      setCurrentMap: mockSetCurrentMap,
    } as any);
    
    vi.mocked(useUIStore).mockReturnValue({
      showConfirm: mockShowConfirm,
    } as any);
    
    vi.mocked(useAuth).mockReturnValue({
      isAdmin: true,
    } as any);
  });

  it('renders map information correctly', () => {
    render(<MapCard map={mockMap} />);
    
    expect(screen.getByText('Test Marina')).toBeInTheDocument();
    expect(screen.getByText('Test description')).toBeInTheDocument();
    expect(screen.getByText('5 boats')).toBeInTheDocument();
    expect(screen.getByText('800 × 600')).toBeInTheDocument();
    expect(screen.getByText('Active')).toBeInTheDocument();
  });

  it('shows selected state correctly', () => {
    vi.mocked(useMapStore).mockReturnValue({
      selectedMapId: 1,
      setCurrentMap: mockSetCurrentMap,
    } as any);
    
    render(<MapCard map={mockMap} />);
    
    expect(screen.getByText('Current')).toBeInTheDocument();
    expect(screen.getByText('Current Map')).toBeInTheDocument();
  });

  it('handles map selection', async () => {
    const user = userEvent.setup();
    
    // Mock window.history.back
    Object.defineProperty(window, 'history', {
      value: { back: vi.fn() },
      writable: true
    });
    
    render(<MapCard map={mockMap} />);
    
    await user.click(screen.getByText('Select Map'));
    
    expect(mockSetCurrentMap).toHaveBeenCalledWith(1);
    expect(window.history.back).toHaveBeenCalled();
  });

  it('shows admin controls for admin users', () => {
    render(<MapCard map={mockMap} />);
    
    expect(screen.getByTitle('Edit map')).toBeInTheDocument();
    expect(screen.getByTitle('Delete map')).toBeInTheDocument();
  });

  it('hides admin controls for non-admin users', () => {
    vi.mocked(useAuth).mockReturnValue({
      isAdmin: false,
    } as any);
    
    render(<MapCard map={mockMap} />);
    
    expect(screen.queryByTitle('Edit map')).not.toBeInTheDocument();
    expect(screen.queryByTitle('Delete map')).not.toBeInTheDocument();
  });

  it('handles delete confirmation', async () => {
    const user = userEvent.setup();
    render(<MapCard map={mockMap} />);
    
    await user.click(screen.getByTitle('Delete map'));
    
    expect(mockShowConfirm).toHaveBeenCalledWith({
      title: 'Delete Map',
      message: 'Are you sure you want to delete "Test Marina"? This will also delete all boat positions on this map.',
      onConfirm: expect.any(Function),
      onCancel: expect.any(Function),
    });
  });

  it('shows inactive status correctly', () => {
    const inactiveMap = { ...mockMap, is_active: false };
    render(<MapCard map={inactiveMap} />);
    
    expect(screen.getByText('Inactive')).toBeInTheDocument();
  });
});

// frontend/src/tests/hooks/useMaps.test.tsx
// frontend/src/tests/hooks/useMaps.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useMaps, useCreateMap, useDeleteMap } from '../../hooks/useMaps';
import * as MapService from '../../services/maps';

vi.mock('../../services/maps');

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });
  
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

describe('useMaps', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('fetches maps successfully', async () => {
    const mockMaps = [
      {
        id: 1,
        name: 'Test Marina',
        description: 'Test description',
        image_path: 'test.jpg',
        image_width: 800,
        image_height: 600,
        is_active: true,
        created_at: '2024-01-01T00:00:00Z',
        boat_count: 5,
      },
    ];

    vi.mocked(MapService.MapService.getMaps).mockResolvedValue(mockMaps);

    const { result } = renderHook(() => useMaps(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual(mockMaps);
    expect(MapService.MapService.getMaps).toHaveBeenCalledWith({ active_only: true });
  });

  it('handles error when fetching maps', async () => {
    const error = new Error('Failed to fetch maps');
    vi.mocked(MapService.MapService.getMaps).mockRejectedValue(error);

    const { result } = renderHook(() => useMaps(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });

    expect(result.current.error).toEqual(error);
  });
});

describe('useCreateMap', () => {
  it('creates map successfully', async () => {
    const newMap = {
      name: 'New Marina',
      description: 'New description',
      image_path: 'new.jpg',
      image_width: 800,
      image_height: 600,
      is_active: true,
    };

    const createdMap = { id: 2, ...newMap, created_at: '2024-01-01T00:00:00Z' };
    vi.mocked(MapService.MapService.createMap).mockResolvedValue(createdMap);

    const { result } = renderHook(() => useCreateMap(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      result.current.mutate(newMap);
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(MapService.MapService.createMap).toHaveBeenCalledWith(newMap);
  });
});

describe('useDeleteMap', () => {
  it('deletes map successfully', async () => {
    vi.mocked(MapService.MapService.deleteMap).mockResolvedValue({ message: 'Map deleted' });

    const { result } = renderHook(() => useDeleteMap(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      result.current.mutate(1);
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(MapService.MapService.deleteMap).toHaveBeenCalledWith(1);
  });
});




// frontend/src/tests/e2e/auth.spec.ts
// frontend/src/tests/e2e/auth.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Authentication', () => {
  test('should login successfully', async ({ page }) => {
    // Mock successful login
    await page.route('**/api/v1/auth/login', async route => {
      await route.fulfill({
        json: { access_token: 'mock-token', token_type: 'bearer' }
      });
    });

    await page.route('**/api/v1/auth/me', async route => {
      await route.fulfill({
        json: {
          id: 1,
          email: 'admin@pier11marina.com',
          full_name: 'Admin User',
          role: 'admin',
          is_active: true
        }
      });
    });

    await page.goto('/');
    
    await expect(page.locator('h2')).toContainText('Pier 11 Marina');
    
    await page.fill('input[name="username"]', 'admin@pier11marina.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    await expect(page.locator('text=Interactive Map')).toBeVisible();
  });

  test('should show error on invalid credentials', async ({ page }) => {
    await page.route('**/api/v1/auth/login', async route => {
      await route.fulfill({
        status: 401,
        json: { detail: 'Incorrect email or password' }
      });
    });

    await page.goto('/');
    
    await page.fill('input[name="username"]', 'wrong@example.com');
    await page.fill('input[name="password"]', 'wrongpassword');
    await page.click('button[type="submit"]');
    
    await expect(page.locator('text=Incorrect email or password')).toBeVisible();
  });

  test('should logout successfully', async ({ page }) => {
    // Mock successful login first
    await page.route('**/api/v1/auth/login', async route => {
      await route.fulfill({
        json: { access_token: 'mock-token', token_type: 'bearer' }
      });
    });

    await page.route('**/api/v1/auth/me', async route => {
      await route.fulfill({
        json: {
          id: 1,
          email: 'admin@pier11marina.com',
          full_name: 'Admin User',
          role: 'admin',
          is_active: true
        }
      });
    });

    await page.goto('/');
    await page.fill('input[name="username"]', 'admin@pier11marina.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    // Logout
    await page.click('text=Sign Out');
    
    // Should return to login page
    await expect(page.locator('h2')).toContainText('Pier 11 Marina');
    await expect(page.locator('input[name="username"]')).toBeVisible();
  });
});

// frontend/src/tests/e2e/map-management.spec.ts
// frontend/src/tests/e2e/map-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Map Management', () => {
  test.beforeEach(async ({ page }) => {
    // Mock API responses
    await page.route('**/api/v1/auth/login', async route => {
      await route.fulfill({
        json: { access_token: 'mock-token', token_type: 'bearer' }
      });
    });

    await page.route('**/api/v1/auth/me', async route => {
      await route.fulfill({
        json: {
          id: 1,
          email: 'admin@pier11marina.com',
          full_name: 'Admin User',
          role: 'admin',
          is_active: true
        }
      });
    });

    await page.route('**/api/v1/maps*', async route => {
      if (route.request().method() === 'GET') {
        await route.fulfill({
          json: [
            {
              id: 1,
              name: 'Pier 11 Marina',
              description: 'Main marina property',
              image_path: 'pier11.jpg',
              image_width: 794,
              image_height: 1123,
              is_active: true,
              created_at: '2024-01-01T00:00:00Z',
              boat_count: 25
            }
          ]
        });
      }
    });

    // Login
    await page.goto('/');
    await page.fill('input[name="username"]', 'admin@pier11marina.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
  });

  test('should navigate to maps page', async ({ page }) => {
    await page.click('text=See Other Maps');
    await expect(page.locator('h1')).toContainText('Marina Maps');
  });

  test('should display existing maps', async ({ page }) => {
    await page.click('text=See Other Maps');
    await expect(page.locator('text=Pier 11 Marina')).toBeVisible();
    await expect(page.locator('text=25 boats')).toBeVisible();
  });

  test('should open map creation form for admin', async ({ page }) => {
    await page.click('text=See Other Maps');
    await page.click('text=Add New Map');
    
    await expect(page.locator('text=Add New Map')).toBeVisible();
    await expect(page.locator('input[name="name"]')).toBeVisible();
  });

  test('should create a new map', async ({ page }) => {
    // Mock the creation endpoint
    await page.route('**/api/v1/maps', async route => {
      if (route.request().method() === 'POST') {
        await route.fulfill({
          json: {
            id: 2,
            name: 'New Marina',
            description: 'Test description',
            image_path: 'new-marina.jpg',
            image_width: 800,
            image_height: 600,
            is_active: true,
            created_at: '2024-01-01T00:00:00Z',
            boat_count: 0
          }
        });
      }
    });

    await page.click('text=See Other Maps');
    await page.click('text=Add New Map');
    
    // Fill form
    await page.fill('input[name="name"]', 'New Marina');
    await page.fill('textarea[name="description"]', 'Test description');
    await page.fill('input[name="image_width"]', '800');
    await page.fill('input[name="image_height"]', '600');
    
    // Mock file input
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles({
      name: 'test-marina.jpg',
      mimeType: 'image/jpeg',
      buffer: Buffer.from('fake-image-content')
    });
    
    await page.click('button:has-text("Create Map")');
    
    // Should close modal and refresh list
    await expect(page.locator('text=Add New Map')).not.toBeVisible();
  });

  test('should validate form inputs', async ({ page }) => {
    await page.click('text=See Other Maps');
    await page.click('text=Add New Map');
    
    // Try to submit empty form
    await page.click('button:has-text("Create Map")');
    
    await expect(page.locator('text=Map name is required')).toBeVisible();
    await expect(page.locator('text=Map image is required')).toBeVisible();
  });

  test('should handle map deletion', async ({ page }) => {
    // Mock delete endpoint
    await page.route('**/api/v1/maps/1', async route => {
      if (route.request().method() === 'DELETE') {
        await route.fulfill({
          json: { message: 'Map deleted successfully' }
        });
      }
    });

    await page.click('text=See Other Maps');
    
    // Click delete button (requires hover to show)
    const mapCard = page.locator('text=Pier 11 Marina').locator('..').locator('..');
    await mapCard.hover();
    await mapCard.locator('[title="Delete map"]').click();
    
    // Confirm deletion
    await page.click('button:has-text("Yes")');
    
    // Map should be removed from list
    await expect(page.locator('text=Pier 11 Marina')).not.toBeVisible();
  });

  test('should select map and navigate back', async ({ page }) => {
    await page.click('text=See Other Maps');
    await page.click('text=Select Map');
    
    // Should navigate back to map view
    await expect(page.locator('h1')).toContainText('Interactive Map');
  });
});

// frontend/src/stores/authStore.ts
// frontend/src/stores/authStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { User, LoginCredentials } from '../types/user';
import { AuthService } from '../services/auth';

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  loadUser: () => Promise<void>;
  clearError: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null,

      login: async (credentials: LoginCredentials) => {
        set({ isLoading: true, error: null });
        
        try {
          await AuthService.login(credentials);
          const user = await AuthService.getCurrentUser();
          set({ user, isAuthenticated: true, isLoading: false });
        } catch (error) {
          set({ 
            error: error instanceof Error ? error.message : 'Login failed',
            isLoading: false,
            isAuthenticated: false 
          });
          throw error;
        }
      },

      logout: () => {
        AuthService.logout();
        set({ user: null, isAuthenticated: false, error: null });
      },

      loadUser: async () => {
        if (!AuthService.isAuthenticated()) {
          set({ isAuthenticated: false, user: null });
          return;
        }

        set({ isLoading: true });
        
        try {
          const user = await AuthService.getCurrentUser();
          if (user) {
            set({ user, isAuthenticated: true, isLoading: false });
          } else {
            set({ isAuthenticated: false, user: null, isLoading: false });
          }
        } catch (error) {
          set({ 
            isAuthenticated: false, 
            user: null, 
            isLoading: false,
            error: 'Session expired'
          });
        }
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ 
        user: state.user, 
        isAuthenticated: state.isAuthenticated 
      }),
    }
  )
);



// frontend/src/stores/uiStore.ts
// frontend/src/stores/uiStore.ts (Updated with map form state)
import { create } from 'zustand';

interface UIState {
  // Sidebar
  sidebarOpen: boolean;
  sidebarWidth: number;
  
  // Map canvas
  selectedPositionId: number | null;
  isMapInteractive: boolean;
  mapZoom: number;
  
  // Modals
  showBoatForm: boolean;
  showMapForm: boolean;
  showConfirmDialog: boolean;
  confirmDialogConfig: {
    title: string;
    message: string;
    onConfirm: () => void;
    onCancel: () => void;
  } | null;
  
  // Loading states
  globalLoading: boolean;
  
  // Navigation
  currentPage: 'map' | 'maps';
  
  // Actions
  toggleSidebar: () => void;
  setSidebarOpen: (open: boolean) => void;
  setSelectedPosition: (positionId: number | null) => void;
  setMapInteractive: (interactive: boolean) => void;
  setMapZoom: (zoom: number) => void;
  showBoatFormModal: () => void;
  hideBoatFormModal: () => void;
  showMapFormModal: () => void;
  hideMapFormModal: () => void;
  showConfirm: (config: UIState['confirmDialogConfig']) => void;
  hideConfirm: () => void;
  setGlobalLoading: (loading: boolean) => void;
  setCurrentPage: (page: 'map' | 'maps') => void;
}

export const useUIStore = create<UIState>((set, get) => ({
  // Initial state
  sidebarOpen: true,
  sidebarWidth: 400,
  selectedPositionId: null,
  isMapInteractive: true,
  mapZoom: 1,
  showBoatForm: false,
  showMapForm: false,
  showConfirmDialog: false,
  confirmDialogConfig: null,
  globalLoading: false,
  currentPage: 'map',

  // Actions
  toggleSidebar: () => {
    set((state) => ({ sidebarOpen: !state.sidebarOpen }));
  },

  setSidebarOpen: (open: boolean) => {
    set({ sidebarOpen: open });
  },

  setSelectedPosition: (positionId: number | null) => {
    set({ selectedPositionId: positionId });
  },

  setMapInteractive: (interactive: boolean) => {
    set({ isMapInteractive: interactive });
  },

  setMapZoom: (zoom: number) => {
    set({ mapZoom: Math.max(0.1, Math.min(3, zoom)) }); // Clamp between 0.1 and 3
  },

  showBoatFormModal: () => {
    set({ showBoatForm: true });
  },

  hideBoatFormModal: () => {
    set({ showBoatForm: false });
  },

  showMapFormModal: () => {
    set({ showMapForm: true });
  },

  hideMapFormModal: () => {
    set({ showMapForm: false });
  },

  showConfirm: (config) => {
    set({ 
      showConfirmDialog: true, 
      confirmDialogConfig: config 
    });
  },

  hideConfirm: () => {
    set({ 
      showConfirmDialog: false, 
      confirmDialogConfig: null 
    });
  },

  setGlobalLoading: (loading: boolean) => {
    set({ globalLoading: loading });
  },

  setCurrentPage: (page: 'map' | 'maps') => {
    set({ currentPage: page });
  },
}));

// frontend/src/stores/mapStore.ts
// frontend/src/stores/mapStore.ts
import { create } from 'zustand';
import { Map, MapWithBoats } from '../types/map';
import { BoatPosition, BoatWithPosition } from '../types/boat';
import { MapService, PositionService } from '../services';

interface MapState {
  // Data
  maps: Map[];
  currentMap: MapWithBoats | null;
  selectedMapId: number | null;
  
  // UI State
  isLoading: boolean;
  error: string | null;
  
  // Actions
  loadMaps: () => Promise<void>;
  loadMap: (mapId: number) => Promise<void>;
  setCurrentMap: (mapId: number) => void;
  createPosition: (positionData: Omit<BoatPosition, 'id' | 'created_at' | 'updated_at'>) => Promise<BoatPosition>;
  updatePosition: (positionId: number, updates: Partial<BoatPosition>) => Promise<void>;
  deletePosition: (positionId: number) => Promise<void>;
  clearError: () => void;
}

export const useMapStore = create<MapState>((set, get) => ({
  // Initial state
  maps: [],
  currentMap: null,
  selectedMapId: null,
  isLoading: false,
  error: null,

  loadMaps: async () => {
    set({ isLoading: true, error: null });
    
    try {
      const maps = await MapService.getMaps({ active_only: true });
      set({ maps, isLoading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Failed to load maps',
        isLoading: false 
      });
    }
  },

  loadMap: async (mapId: number) => {
    set({ isLoading: true, error: null });
    
    try {
      const mapWithBoats = await MapService.getMapWithBoats(mapId);
      set({ 
        currentMap: mapWithBoats,
        selectedMapId: mapId,
        isLoading: false 
      });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Failed to load map',
        isLoading: false 
      });
    }
  },

  setCurrentMap: (mapId: number) => {
    const { loadMap } = get();
    loadMap(mapId);
  },

  createPosition: async (positionData) => {
    const { currentMap } = get();
    
    try {
      const newPosition = await PositionService.createPosition({
        ...positionData,
        map_id: currentMap!.map.id
      });
      
      // Update local state
      if (currentMap) {
        const newBoatWithPosition: BoatWithPosition = {
          boat: undefined,
          position: newPosition
        };
        
        const updatedMap = {
          ...currentMap,
          boats: [...currentMap.boats, newBoatWithPosition]
        };
        
        set({ currentMap: updatedMap });
      }
      
      return newPosition;
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Failed to create position' });
      throw error;
    }
  },

  updatePosition: async (positionId: number, updates: Partial<BoatPosition>) => {
    const { currentMap } = get();
    
    try {
      await PositionService.updatePosition(positionId, updates);
      
      // Update local state
      if (currentMap) {
        const updatedBoats = currentMap.boats.map(boatWithPos => {
          if (boatWithPos.position.id === positionId) {
            return {
              ...boatWithPos,
              position: { ...boatWithPos.position, ...updates }
            };
          }
          return boatWithPos;
        });
        
        set({ 
          currentMap: { 
            ...currentMap, 
            boats: updatedBoats 
          }
        });
      }
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Failed to update position' });
      throw error;
    }
  },

  deletePosition: async (positionId: number) => {
    const { currentMap } = get();
    
    try {
      await PositionService.deletePosition(positionId);
      
      // Update local state
      if (currentMap) {
        const updatedBoats = currentMap.boats.filter(
          boatWithPos => boatWithPos.position.id !== positionId
        );
        
        set({ 
          currentMap: { 
            ...currentMap, 
            boats: updatedBoats 
          }
        });
      }
    } catch (error) {
      set({ error: error instanceof Error ? error.message : 'Failed to delete position' });
      throw error;
    }
  },

  clearError: () => set({ error: null }),
}));



// frontend/src/utils/cn.ts
// frontend/src/utils/cn.ts (className utility)
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}



// frontend/src/utils/storage.ts
// frontend/src/utils/storage.ts
export class Storage {
  static get<T>(key: string, defaultValue?: T): T | null {
    try {
      const item = localStorage.getItem(key);
      if (item === null) return defaultValue || null;
      return JSON.parse(item);
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return defaultValue || null;
    }
  }

  static set<T>(key: string, value: T): void {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Error writing to localStorage:', error);
    }
  }

  static remove(key: string): void {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error('Error removing from localStorage:', error);
    }
  }

  static clear(): void {
    try {
      localStorage.clear();
    } catch (error) {
      console.error('Error clearing localStorage:', error);
    }
  }
}



// frontend/src/utils/constants.ts
// frontend/src/utils/constants.ts
export const BOAT_COLORS = [
  'blue', 'red', 'green', 'yellow', 'orange', 
  'purple', 'pink', 'brown', 'gray', 'navy',
  'teal', 'lime', 'maroon', 'olive'
] as const;

export const BOAT_SECTIONS = ['A', 'B', 'C', 'D', 'E', 'F'] as const;

export const MAP_DEFAULTS = {
  BOAT_WIDTH: 100,
  BOAT_HEIGHT: 50,
  BOAT_COLOR: 'blue',
  STROKE_COLOR: 'black',
  STROKE_WIDTH: 1,
} as const;

export const PAGINATION = {
  DEFAULT_PAGE_SIZE: 10,
  MAX_PAGE_SIZE: 100,
} as const;



// frontend/src/utils/validators.ts
// frontend/src/utils/validators.ts
import { BoatListingCreate } from '../types/boat';
import { BOAT_SECTIONS } from './constants';

export interface ValidationError {
  field: string;
  message: string;
}

export const validateBoatListing = (data: BoatListingCreate): ValidationError[] => {
  const errors: ValidationError[] = [];
  
  // Required fields
  if (!data.customer_name.trim()) {
    errors.push({ field: 'customer_name', message: 'Customer name is required' });
  }
  
  if (!data.index || data.index <= 0) {
    errors.push({ field: 'index', message: 'Index must be a positive number' });
  }
  
  // Optional field validation
  if (data.section && !BOAT_SECTIONS.includes(data.section as any)) {
    errors.push({ 
      field: 'section', 
      message: `Section must be one of: ${BOAT_SECTIONS.join(', ')}` 
    });
  }
  
  if (data.customer_name.length > 100) {
    errors.push({ 
      field: 'customer_name', 
      message: 'Customer name must be less than 100 characters' 
    });
  }
  
  if (data.name && data.name.length > 100) {
    errors.push({ 
      field: 'name', 
      message: 'Boat name must be less than 100 characters' 
    });
  }
  
  return errors;
};

export const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};



// frontend/src/utils/formatters.ts
// frontend/src/utils/formatters.ts
import { BoatListing } from '../types/boat';

export const formatBoatTitle = (boat: BoatListing): string => {
  const parts: string[] = [`#${boat.index}`];
  
  if (boat.name) parts.push(boat.name);
  if (boat.make_model) parts.push(boat.make_model);
  if (boat.size) parts.push(`(${boat.size})`);
  
  return parts.join(' ');
};

export const formatBoatSubtitle = (boat: BoatListing): string => {
  const parts: string[] = [boat.customer_name];
  
  if (boat.vehicle_type) parts.push(`• ${boat.vehicle_type}`);
  if (boat.section) parts.push(`• Section ${boat.section}`);
  
  return parts.join(' ');
};

export const formatDate = (dateString: string): string => {
  return new Date(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  });
};

export const formatDateTime = (dateString: string): string => {
  return new Date(dateString).toLocaleString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });
};



<!-- frontend/src/styles/globals.css -->
// frontend/src/styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html {
    font-family: 'Inter', system-ui, sans-serif;
  }
  
  body {
    @apply bg-gray-50 text-gray-900;
  }
  
  * {
    @apply border-border;
  }
}

@layer components {
  .btn {
    @apply inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none;
  }
  
  .btn-primary {
    @apply bg-primary-600 text-white hover:bg-primary-700;
  }
  
  .btn-secondary {
    @apply bg-gray-200 text-gray-900 hover:bg-gray-300;
  }
  
  .btn-danger {
    @apply bg-red-600 text-white hover:bg-red-700;
  }
  
  .form-input {
    @apply block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500;
  }
}

// frontend/src/components/auth/LoginForm.tsx
// frontend/src/components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useAuth } from '../../hooks/useAuth';
import { Button } from '../common/Button';
import { LoadingSpinner } from '../common/LoadingSpinner';

export const LoginForm: React.FC = () => {
  const { login, isLoading, error } = useAuth();
  const [credentials, setCredentials] = useState({
    username: '',
    password: '',
  });
  const [showPassword, setShowPassword] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!credentials.username.trim() || !credentials.password) {
      return;
    }

    try {
      await login(credentials);
    } catch (error) {
      // Error is handled by the auth store
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setCredentials(prev => ({ ...prev, [name]: value }));
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <div className="mx-auto h-16 w-16 flex items-center justify-center rounded-full bg-blue-100">
            <svg className="h-8 w-8 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Pier 11 Marina
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            Interactive Map System
          </p>
        </div>
        
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          <div className="space-y-4">
            <div>
              <label htmlFor="username" className="block text-sm font-medium text-gray-700">
                Email Address
              </label>
              <input
                id="username"
                name="username"
                type="email"
                required
                value={credentials.username}
                onChange={handleChange}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                placeholder="Enter your email"
                disabled={isLoading}
              />
            </div>
            
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                Password
              </label>
              <div className="mt-1 relative">
                <input
                  id="password"
                  name="password"
                  type={showPassword ? 'text' : 'password'}
                  required
                  value={credentials.password}
                  onChange={handleChange}
                  className="block w-full px-3 py-2 pr-10 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="Enter your password"
                  disabled={isLoading}
                />
                <button
                  type="button"
                  className="absolute inset-y-0 right-0 pr-3 flex items-center"
                  onClick={() => setShowPassword(!showPassword)}
                  disabled={isLoading}
                >
                  <svg className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    {showPassword ? (
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21" />
                    ) : (
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    )}
                  </svg>
                </button>
              </div>
            </div>
          </div>

          {error && (
            <div className="bg-red-50 border border-red-200 rounded-md p-4">
              <div className="flex">
                <div className="flex-shrink-0">
                  <svg className="h-5 w-5 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <div className="ml-3">
                  <p className="text-sm text-red-700">{error}</p>
                </div>
              </div>
            </div>
          )}

          <div>
            <Button
              type="submit"
              className="w-full"
              isLoading={isLoading}
              disabled={!credentials.username.trim() || !credentials.password}
            >
              {isLoading ? (
                <LoadingSpinner size="sm" className="text-white" />
              ) : (
                'Sign In'
              )}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
};



// frontend/src/components/auth/ProtectedRoute.tsx
// frontend/src/components/auth/ProtectedRoute.tsx
import React from 'react';
import { useAuth } from '../../hooks/useAuth';
import { LoginForm } from './LoginForm';
import { LoadingSpinner } from '../common/LoadingSpinner';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <LoadingSpinner size="lg" />
      </div>
    );
  }

  if (!isAuthenticated) {
    return <LoginForm />;
  }

  return <>{children}</>;
};



// frontend/src/components/layout/NavBar.tsx
// frontend/src/components/layout/Navbar.tsx (Updated with maps navigation)
import React from 'react';
import { useAuth } from '../../hooks/useAuth';
import { useMaps } from '../../hooks/useMaps';
import { useMapStore } from '../../stores/mapStore';
import { useUIStore } from '../../stores/uiStore';
import { Button } from '../common/Button';

export const Navbar: React.FC = () => {
  const { user, logout } = useAuth();
  const { data: maps = [] } = useMaps();
  const { selectedMapId, setCurrentMap } = useMapStore();
  const { toggleSidebar, currentPage, setCurrentPage } = useUIStore();

  const currentMap = maps.find(map => map.id === selectedMapId);

  const handleMapSelect = (mapId: number) => {
    setCurrentMap(mapId);
    if (currentPage === 'maps') {
      setCurrentPage('map');
    }
  };

  const handleViewMaps = () => {
    setCurrentPage('maps');
  };

  return (
    <nav className="bg-white shadow-sm border-b px-4 py-3 flex items-center justify-between">
      <div className="flex items-center space-x-4">
        <Button
          variant="ghost"
          size="sm"
          onClick={toggleSidebar}
          className="lg:hidden"
        >
          <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
          </svg>
        </Button>
        
        <h1 className="text-xl font-semibold text-gray-900">
          Pier 11 Marina {currentPage === 'maps' ? 'Maps' : 'Interactive Map'}
        </h1>
      </div>
      
      <div className="flex items-center space-x-4">
        {/* Current Map & Navigation */}
        {currentPage === 'map' && currentMap && (
          <div className="flex items-center space-x-3">
            <div className="text-sm text-gray-600">
              <span className="font-medium">{currentMap.name}</span>
              <span className="ml-2">({currentMap.boat_count} boats)</span>
            </div>
            
            <Button
              variant="ghost"
              size="sm"
              onClick={handleViewMaps}
            >
              See Other Maps
            </Button>
          </div>
        )}
        
        {/* Map Selector for Maps Page */}
        {currentPage === 'maps' && currentMap && (
          <div className="text-sm text-gray-600">
            Current: <span className="font-medium">{currentMap.name}</span>
          </div>
        )}
        
        {/* Quick Map Selector Dropdown */}
        {currentPage === 'map' && maps.length > 1 && (
          <div className="flex items-center space-x-2">
            <select
              value={selectedMapId || ''}
              onChange={(e) => handleMapSelect(Number(e.target.value))}
              className="border border-gray-300 rounded-md px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              <option value="">Select map...</option>
              {maps.map((map) => (
                <option key={map.id} value={map.id}>
                  {map.name}
                </option>
              ))}
            </select>
          </div>
        )}
        
        {/* User Menu */}
        <div className="flex items-center space-x-2 text-sm">
          <span className="text-gray-600">
            {user?.full_name} ({user?.role})
          </span>
          <Button
            variant="ghost"
            size="sm"
            onClick={logout}
          >
            Sign Out
          </Button>
        </div>
      </div>
    </nav>
  );
};

// frontend/src/components/layout/Layout.tsx
// frontend/src/components/layout/Layout.tsx
import React, { useEffect } from 'react';
import { Navbar } from './Navbar';
import { Sidebar } from './Sidebar';
import { useMapStore } from '../../stores/mapStore';
import { useMaps } from '../../hooks/useMaps';

interface LayoutProps {
  children: React.ReactNode;
}

export const Layout: React.FC<LayoutProps> = ({ children }) => {
  const { data: maps = [] } = useMaps();
  const { selectedMapId, setCurrentMap } = useMapStore();

  // Auto-select first map if none selected
  useEffect(() => {
    if (maps.length > 0 && !selectedMapId) {
      setCurrentMap(maps[0].id);
    }
  }, [maps, selectedMapId, setCurrentMap]);

  return (
    <div className="h-screen flex flex-col">
      <Navbar />
      <div className="flex-1 flex overflow-hidden">
        <Sidebar />
        <main className="flex-1 overflow-hidden">
          {children}
        </main>
      </div>
    </div>
  );
};

// frontend/src/components/layout/Sidebar.tsx
// frontend/src/components/layout/Sidebar.tsx
import React from 'react';
import { useUIStore } from '../../stores/uiStore';
import { BoatList } from '../boat/BoatList';
import { BoatSearch } from '../boat/BoatSearch';
import { cn } from '../../utils/cn';

export const Sidebar: React.FC = () => {
  const { sidebarOpen, sidebarWidth, toggleSidebar } = useUIStore();

  return (
    <>
      {/* Mobile backdrop */}
      {sidebarOpen && (
        <div 
          className="lg:hidden fixed inset-0 bg-black bg-opacity-50 z-40"
          onClick={toggleSidebar}
        />
      )}
      
      {/* Sidebar */}
      <div className={cn(
        'fixed lg:relative inset-y-0 left-0 z-50 flex flex-col bg-white border-r border-gray-200 transform transition-transform duration-300 ease-in-out',
        sidebarOpen ? 'translate-x-0' : '-translate-x-full lg:translate-x-0',
      )} style={{ width: sidebarWidth }}>
        
        {/* Sidebar header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200">
          <h2 className="text-lg font-semibold text-gray-900">
            Boat Listings
          </h2>
          <button
            onClick={toggleSidebar}
            className="lg:hidden p-1 rounded-md hover:bg-gray-100"
          >
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        {/* Search */}
        <div className="p-4 border-b border-gray-200">
          <BoatSearch />
        </div>
        
        {/* Boat list */}
        <div className="flex-1 overflow-y-auto">
          <BoatList />
        </div>
      </div>
    </>
  );
};



// frontend/src/components/boat/BoatForm.tsx
// frontend/src/components/boat/BoatForm.tsx
import React, { useState, useEffect } from 'react';
import { BoatListing, BoatListingCreate, BoatListingUpdate } from '../../types/boat';
import { useCreateBoat, useUpdateBoat } from '../../hooks/useBoats';
import { Modal } from '../common/Modal';
import { Button } from '../common/Button';
import { useUIStore } from '../../stores/uiStore';

interface BoatFormProps {
  boat?: BoatListing;
}

export const BoatForm: React.FC<BoatFormProps> = ({ boat }) => {
  const { showBoatForm, hideBoatFormModal } = useUIStore();
  const createBoat = useCreateBoat();
  const updateBoat = useUpdateBoat();
  
  const [formData, setFormData] = useState<BoatListingCreate>({
    index: 0,
    customer_name: '',
    name: '',
    size: '',
    make_model: '',
    vehicle_type: '',
    section: '',
    notes: '',
  });

  const [errors, setErrors] = useState<Record<string, string>>({});

  // Load boat data when editing
  useEffect(() => {
    if (boat) {
      setFormData({
        index: boat.index,
        customer_name: boat.customer_name,
        name: boat.name || '',
        size: boat.size || '',
        make_model: boat.make_model || '',
        vehicle_type: boat.vehicle_type || '',
        section: boat.section || '',
        notes: boat.notes || '',
      });
    } else {
      // Reset form for new boat
      setFormData({
        index: 0,
        customer_name: '',
        name: '',
        size: '',
        make_model: '',
        vehicle_type: '',
        section: '',
        notes: '',
      });
    }
    setErrors({});
  }, [boat]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.customer_name.trim()) {
      newErrors.customer_name = 'Customer name is required';
    }
    
    if (!formData.index || formData.index <= 0) {
      newErrors.index = 'Index must be a positive number';
    }
    
    if (formData.section && !['A', 'B', 'C', 'D', 'E', 'F'].includes(formData.section.toUpperCase())) {
      newErrors.section = 'Section must be A, B, C, D, E, or F';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;

    try {
      if (boat) {
        await updateBoat.mutateAsync({
          id: boat.id,
          data: formData as BoatListingUpdate
        });
      } else {
        await createBoat.mutateAsync(formData);
      }
      
      hideBoatFormModal();
    } catch (error) {
      console.error('Form submission error:', error);
    }
  };

  const isLoading = createBoat.isPending || updateBoat.isPending;

  return (
    <Modal
      isOpen={showBoatForm}
      onClose={hideBoatFormModal}
      title={boat ? 'Edit Boat' : 'Add New Boat'}
      size="md"
    >
      <form onSubmit={handleSubmit} className="space-y-4">
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label htmlFor="index" className="block text-sm font-medium text-gray-700 mb-1">
              Index *
            </label>
            <input
              id="index"
              name="index"
              type="number"
              min="1"
              value={formData.index}
              onChange={handleChange}
              className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                errors.index ? 'border-red-300' : 'border-gray-300'
              }`}
              disabled={isLoading}
            />
            {errors.index && <p className="text-red-600 text-sm mt-1">{errors.index}</p>}
          </div>
          
          <div>
            <label htmlFor="section" className="block text-sm font-medium text-gray-700 mb-1">
              Section
            </label>
            <select
              id="section"
              name="section"
              value={formData.section}
              onChange={handleChange}
              className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                errors.section ? 'border-red-300' : 'border-gray-300'
              }`}
              disabled={isLoading}
            >
              <option value="">Select section</option>
              <option value="A">Section A</option>
              <option value="B">Section B</option>
              <option value="C">Section C</option>
              <option value="D">Section D</option>
              <option value="E">Section E</option>
              <option value="F">Section F</option>
            </select>
            {errors.section && <p className="text-red-600 text-sm mt-1">{errors.section}</p>}
          </div>
        </div>

        <div>
          <label htmlFor="customer_name" className="block text-sm font-medium text-gray-700 mb-1">
            Customer Name *
          </label>
          <input
            id="customer_name"
            name="customer_name"
            type="text"
            value={formData.customer_name}
            onChange={handleChange}
            className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
              errors.customer_name ? 'border-red-300' : 'border-gray-300'
            }`}
            disabled={isLoading}
          />
          {errors.customer_name && <p className="text-red-600 text-sm mt-1">{errors.customer_name}</p>}
        </div>

        <div>
          <label htmlFor="name" className="block text-sm font-medium text-gray-700 mb-1">
            Boat Name
          </label>
          <input
            id="name"
            name="name"
            type="text"
            value={formData.name}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label htmlFor="size" className="block text-sm font-medium text-gray-700 mb-1">
              Size
            </label>
            <input
              id="size"
              name="size"
              type="text"
              placeholder="e.g., 30 ft"
              value={formData.size}
              onChange={handleChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isLoading}
            />
          </div>
          
          <div>
            <label htmlFor="vehicle_type" className="block text-sm font-medium text-gray-700 mb-1">
              Vehicle Type
            </label>
            <input
              id="vehicle_type"
              name="vehicle_type"
              type="text"
              placeholder="e.g., boat, trailer, jetski"
              value={formData.vehicle_type}
              onChange={handleChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isLoading}
            />
          </div>
        </div>

        <div>
          <label htmlFor="make_model" className="block text-sm font-medium text-gray-700 mb-1">
            Make & Model
          </label>
          <input
            id="make_model"
            name="make_model"
            type="text"
            placeholder="e.g., Sea Ray Sundancer"
            value={formData.make_model}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <div>
          <label htmlFor="notes" className="block text-sm font-medium text-gray-700 mb-1">
            Notes
          </label>
          <textarea
            id="notes"
            name="notes"
            rows={3}
            value={formData.notes}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            disabled={isLoading}
          />
        </div>

        <div className="flex justify-end space-x-3 pt-4">
          <Button
            type="button"
            variant="secondary"
            onClick={hideBoatFormModal}
            disabled={isLoading}
          >
            Cancel
          </Button>
          <Button
            type="submit"
            isLoading={isLoading}
          >
            {boat ? 'Update Boat' : 'Create Boat'}
          </Button>
        </div>
      </form>
    </Modal>
  );
};

// frontend/src/components/boat/BoatSearch.tsx
// frontend/src/components/boat/BoatSearch.tsx
import React, { useState } from 'react';
import { useDebounce } from '../../hooks/useDebounce';
import { useUIStore } from '../../stores/uiStore';

export const BoatSearch: React.FC = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const { showBoatFormModal } = useUIStore();
  
  // TODO: Connect to boat search functionality
  const debouncedSearch = useDebounce(searchTerm, 300);

  return (
    <div className="space-y-3">
      <div className="relative">
        <input
          type="text"
          placeholder="Search boats..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
        />
        <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
          <svg className="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>
      </div>
      
      <button
        onClick={showBoatFormModal}
        className="w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center"
      >
        <svg className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
        </svg>
        Add New Boat
      </button>
    </div>
  );
};



// frontend/src/components/boat/BoatList.tsx
// frontend/src/components/boat/BoatList.tsx
import React, { useState } from 'react';
import { useBoats } from '../../hooks/useBoats';
import { useDebounce } from '../../hooks/useDebounce';
import { BoatCard } from './BoatCard';
import { LoadingSpinner } from '../common/LoadingSpinner';
import { Button } from '../common/Button';
import { BoatSearchParams } from '../../types/boat';

export const BoatList: React.FC = () => {
  const [searchParams, setSearchParams] = useState<BoatSearchParams>({
    skip: 0,
    limit: 10,
    search: '',
    mapped_only: undefined,
    section: undefined,
  });

  const debouncedSearch = useDebounce(searchParams.search || '', 300);
  const { data: boats = [], isLoading, error } = useBoats({
    ...searchParams,
    search: debouncedSearch,
  });

  const handleLoadMore = () => {
    setSearchParams(prev => ({
      ...prev,
      skip: (prev.skip || 0) + (prev.limit || 10),
    }));
  };

  const handleFilterChange = (key: keyof BoatSearchParams, value: any) => {
    setSearchParams(prev => ({
      ...prev,
      [key]: value,
      skip: 0, // Reset pagination when filtering
    }));
  };

  if (error) {
    return (
      <div className="p-4 text-center">
        <p className="text-red-600 mb-4">Failed to load boats</p>
        <Button onClick={() => window.location.reload()}>
          Retry
        </Button>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      {/* Filters */}
      <div className="p-4 space-y-3 border-b border-gray-200">
        <div className="flex space-x-2">
          <select
            value={searchParams.mapped_only === undefined ? '' : searchParams.mapped_only.toString()}
            onChange={(e) => handleFilterChange('mapped_only', 
              e.target.value === '' ? undefined : e.target.value === 'true'
            )}
            className="flex-1 px-3 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Boats</option>
            <option value="true">Mapped Only</option>
            <option value="false">Unmapped Only</option>
          </select>
          
          <select
            value={searchParams.section || ''}
            onChange={(e) => handleFilterChange('section', e.target.value || undefined)}
            className="flex-1 px-3 py-1 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="">All Sections</option>
            <option value="A">Section A</option>
            <option value="B">Section B</option>
            <option value="C">Section C</option>
            <option value="D">Section D</option>
            <option value="E">Section E</option>
            <option value="F">Section F</option>
          </select>
        </div>
        
        <Button
          onClick={() => setSearchParams({ skip: 0, limit: 10, search: '' })}
          variant="ghost"
          size="sm"
          className="w-full"
        >
          Clear Filters
        </Button>
      </div>

      {/* Boat list */}
      <div className="flex-1 overflow-y-auto">
        {isLoading && boats.length === 0 ? (
          <div className="flex justify-center py-8">
            <LoadingSpinner />
          </div>
        ) : (
          <>
            {boats.length === 0 ? (
              <div className="p-4 text-center text-gray-500">
                <p>No boats found</p>
                <p className="text-sm mt-1">Try adjusting your search or filters</p>
              </div>
            ) : (
              <div className="space-y-2 p-4">
                {boats.map((boat) => (
                  <BoatCard key={boat.id} boat={boat} />
                ))}
                
                {boats.length >= (searchParams.limit || 10) && (
                  <div className="pt-4">
                    <Button
                      onClick={handleLoadMore}
                      variant="ghost"
                      size="sm"
                      className="w-full"
                      isLoading={isLoading}
                    >
                      Load More
                    </Button>
                  </div>
                )}
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
};



// frontend/src/components/boat/BoatCard.tsx
// frontend/src/components/boat/BoatCard.tsx
import React from 'react';
import { BoatListing } from '../../types/boat';
import { useDeleteBoat, useAssignBoat } from '../../hooks/useBoats';
import { useUIStore } from '../../stores/uiStore';
import { useMapStore } from '../../stores/mapStore';
import { Button } from '../common/Button';

interface BoatCardProps {
  boat: BoatListing;
}

export const BoatCard: React.FC<BoatCardProps> = ({ boat }) => {
  const { showConfirm, showBoatFormModal, setSelectedPosition } = useUIStore();
  const { currentMap } = useMapStore();
  const deleteBoat = useDeleteBoat();
  const assignBoat = useAssignBoat();

  const handleEdit = () => {
    // TODO: Set selected boat for editing
    showBoatFormModal();
  };

  const handleDelete = () => {
    showConfirm({
      title: 'Delete Boat',
      message: `Are you sure you want to delete boat #${boat.index} (${boat.name || 'Untitled'})?`,
      onConfirm: () => {
        deleteBoat.mutate(boat.id);
      },
      onCancel: () => {},
    });
  };

  const handleViewOnMap = () => {
    if (boat.position_id && currentMap) {
      const boatWithPosition = currentMap.boats.find(
        b => b.position?.id === boat.position_id
      );
      if (boatWithPosition) {
        setSelectedPosition(boat.position_id);
        // TODO: Center map on boat position
      }
    }
  };

  const handleAssignToSelected = () => {
    // TODO: Get selected position from map and assign boat
    console.log('Assign boat to selected position');
  };

  const formatBoatTitle = () => {
    const parts = [`#${boat.index}`];
    if (boat.name) parts.push(boat.name);
    if (boat.make_model) parts.push(boat.make_model);
    if (boat.size) parts.push(`(${boat.size})`);
    return parts.join(' ');
  };

  return (
    <div className={`
      bg-white border rounded-lg p-3 hover:shadow-md transition-shadow
      ${boat.is_mapped ? 'border-green-200 bg-green-50' : 'border-gray-200'}
    `}>
      <div className="flex justify-between items-start mb-2">
        <div className="flex-1">
          <h3 className="font-medium text-gray-900 text-sm">
            {formatBoatTitle()}
          </h3>
          <p className="text-sm text-gray-600">
            {boat.customer_name}
          </p>
        </div>
        
        <div className="flex items-center space-x-1">
          <Button
            size="sm"
            variant="ghost"
            onClick={handleEdit}
            title="Edit boat details"
          >
            <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
          </Button>
          
          <Button
            size="sm"
            variant="ghost"
            onClick={handleDelete}
            title="Delete boat"
            className="text-red-600 hover:text-red-700"
          >
            <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
          </Button>
        </div>
      </div>
      
      {/* Additional details */}
      <div className="space-y-1 text-xs text-gray-500">
        {boat.vehicle_type && (
          <div>Type: {boat.vehicle_type}</div>
        )}
        {boat.section && (
          <div>Section: {boat.section}</div>
        )}
        {boat.notes && (
          <div className="truncate" title={boat.notes}>
            Notes: {boat.notes}
          </div>
        )}
      </div>
      
      {/* Action buttons */}
      <div className="mt-3 flex space-x-2">
        {boat.is_mapped ? (
          <Button
            size="sm"
            variant="secondary"
            onClick={handleViewOnMap}
            className="flex-1 text-xs"
          >
            View on Map
          </Button>
        ) : (
          <Button
            size="sm"
            variant="primary"
            onClick={handleAssignToSelected}
            className="flex-1 text-xs"
          >
            Assign to Map
          </Button>
        )}
      </div>
    </div>
  );
};



// frontend/src/components/common/ConfirmDialog.tsx
// frontend/src/components/common/ConfirmDialog.tsx
import React from 'react';
import { Modal } from './Modal';
import { Button } from './Button';

interface ConfirmDialogProps {
  isOpen: boolean;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  onConfirm: () => void;
  onCancel: () => void;
  isLoading?: boolean;
  variant?: 'danger' | 'primary';
}

export const ConfirmDialog: React.FC<ConfirmDialogProps> = ({
  isOpen,
  title,
  message,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  onConfirm,
  onCancel,
  isLoading = false,
  variant = 'primary',
}) => {
  return (
    <Modal isOpen={isOpen} onClose={onCancel} title={title} size="sm">
      <div className="space-y-4">
        <p className="text-gray-600">{message}</p>
        
        <div className="flex justify-end space-x-3">
          <Button
            variant="secondary"
            onClick={onCancel}
            disabled={isLoading}
          >
            {cancelText}
          </Button>
          <Button
            variant={variant}
            onClick={onConfirm}
            isLoading={isLoading}
          >
            {confirmText}
          </Button>
        </div>
      </div>
    </Modal>
  );
};



// frontend/src/components/common/FileUpload.tsx
// frontend/src/components/common/FileUpload.tsx
import React, { useRef, useState } from 'react';
import { Button } from './Button';

interface FileUploadProps {
  onFileSelect: (file: File) => void;
  acceptedTypes?: string[];
  maxSize?: number; // in bytes
  disabled?: boolean;
  className?: string;
}

export const FileUpload: React.FC<FileUploadProps> = ({
  onFileSelect,
  acceptedTypes = ['image/*'],
  maxSize = 5 * 1024 * 1024, // 5MB default
  disabled = false,
  className = '',
}) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [dragOver, setDragOver] = useState(false);
  const [error, setError] = useState<string>('');

  const validateFile = (file: File): string | null => {
    // Check file type
    if (acceptedTypes.length > 0) {
      const isValidType = acceptedTypes.some(type => {
        if (type.endsWith('/*')) {
          return file.type.startsWith(type.replace('/*', '/'));
        }
        return file.type === type;
      });
      
      if (!isValidType) {
        return `File type ${file.type} is not supported. Accepted types: ${acceptedTypes.join(', ')}`;
      }
    }

    // Check file size
    if (file.size > maxSize) {
      const maxMB = (maxSize / (1024 * 1024)).toFixed(1);
      return `File size must be less than ${maxMB}MB`;
    }

    return null;
  };

  const handleFileSelect = (file: File) => {
    const validationError = validateFile(file);
    if (validationError) {
      setError(validationError);
      return;
    }

    setError('');
    onFileSelect(file);
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    if (!disabled) {
      setDragOver(true);
    }
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setDragOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setDragOver(false);
    
    if (disabled) return;

    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      handleFileSelect(files[0]);
    }
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      handleFileSelect(files[0]);
    }
  };

  const handleClick = () => {
    if (!disabled && fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  return (
    <div className={className}>
      <div
        className={`
          border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors
          ${dragOver 
            ? 'border-blue-400 bg-blue-50' 
            : 'border-gray-300 hover:border-gray-400'
          }
          ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
        `}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={handleClick}
      >
        <svg className="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
        </svg>
        
        <p className="text-sm text-gray-600 mb-2">
          <span className="font-medium">Click to upload</span> or drag and drop
        </p>
        <p className="text-xs text-gray-500">
          {acceptedTypes.join(', ')} up to {(maxSize / (1024 * 1024)).toFixed(1)}MB
        </p>
        
        <Button
          type="button"
          size="sm"
          className="mt-4"
          disabled={disabled}
        >
          Choose File
        </Button>
      </div>

      <input
        ref={fileInputRef}
        type="file"
        accept={acceptedTypes.join(',')}
        onChange={handleInputChange}
        className="hidden"
        disabled={disabled}
      />

      {error && (
        <p className="text-red-600 text-sm mt-2">{error}</p>
      )}
    </div>
  );
};

// frontend/src/components/common/LoadingSpinner.tsx
// frontend/src/components/common/LoadingSpinner.tsx
import React from 'react';
import { cn } from '../../utils/cn';

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  className,
}) => {
  const sizes = {
    sm: 'h-4 w-4',
    md: 'h-8 w-8',
    lg: 'h-12 w-12',
  };

  return (
    <div className={cn('animate-spin', sizes[size], className)}>
      <svg fill="none" viewBox="0 0 24 24">
        <circle
          className="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          strokeWidth="4"
        />
        <path
          className="opacity-75"
          fill="currentColor"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        />
      </svg>
    </div>
  );
};



// frontend/src/components/common/Button.tsx
// frontend/src/components/common/Button.tsx
import React from 'react';
import { cn } from '../../utils/cn';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  children,
  variant = 'primary',
  size = 'md',
  isLoading = false,
  className,
  disabled,
  ...props
}) => {
  const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none';
  
  const variants = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
    danger: 'bg-red-600 text-white hover:bg-red-700',
    ghost: 'hover:bg-gray-100 text-gray-700',
  };
  
  const sizes = {
    sm: 'h-8 px-3 text-sm',
    md: 'h-10 px-4',
    lg: 'h-12 px-6 text-lg',
  };

  return (
    <button
      className={cn(baseClasses, variants[variant], sizes[size], className)}
      disabled={disabled || isLoading}
      {...props}
    >
      {isLoading && (
        <svg className="mr-2 h-4 w-4 animate-spin" fill="none" viewBox="0 0 24 24">
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
      )}
      {children}
    </button>
  );
};



// frontend/src/components/common/Modal.tsx
// frontend/src/components/common/Modal.tsx
import React, { useEffect } from 'react';
import { createPortal } from 'react-dom';
import { cn } from '../../utils/cn';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  size?: 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
}

export const Modal: React.FC<ModalProps> = ({
  isOpen,
  onClose,
  title,
  children,
  size = 'md',
  className,
}) => {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  const sizes = {
    sm: 'max-w-md',
    md: 'max-w-lg',
    lg: 'max-w-2xl',
    xl: 'max-w-4xl',
  };

  return createPortal(
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
      <div 
        className="fixed inset-0 bg-black bg-opacity-50 transition-opacity"
        onClick={onClose}
      />
      <div className={cn(
        'relative bg-white rounded-lg shadow-xl w-full',
        sizes[size],
        className
      )}>
        {title && (
          <div className="flex items-center justify-between p-6 border-b">
            <h2 className="text-lg font-semibold text-gray-900">{title}</h2>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors"
            >
              <span className="sr-only">Close</span>
              <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        )}
        <div className="p-6">
          {children}
        </div>
      </div>
    </div>,
    document.body
  );
};



// frontend/src/components/common/ErrorBoundary.tsx
// frontend/src/components/common/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
          <div className="max-w-md w-full bg-white shadow-lg rounded-lg p-6">
            <div className="flex items-center mb-4">
              <div className="flex-shrink-0">
                <svg
                  className="h-8 w-8 text-red-400"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"
                  />
                </svg>
              </div>
              <div className="ml-3">
                <h3 className="text-lg font-medium text-gray-900">
                  Something went wrong
                </h3>
              </div>
            </div>
            
            <div className="mb-4">
              <p className="text-sm text-gray-600">
                We encountered an unexpected error. Please try refreshing the page.
              </p>
              {this.state.error && (
                <details className="mt-2">
                  <summary className="text-sm text-gray-500 cursor-pointer">
                    Technical details
                  </summary>
                  <pre className="mt-2 text-xs text-red-600 bg-red-50 p-2 rounded overflow-auto">
                    {this.state.error.message}
                  </pre>
                </details>
              )}
            </div>
            
            <button
              onClick={() => window.location.reload()}
              className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors"
            >
              Refresh Page
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}



// frontend/src/components/map/MapManagementPage.tsx
// frontend/src/components/map/MapManagementPage.tsx
import React from 'react';
import { useMaps, useCreateMap } from '../../hooks/useMaps';
import { useAuth } from '../../hooks/useAuth';
import { useUIStore } from '../../stores/uiStore';
import { Button } from '../common/Button';
import { LoadingSpinner } from '../common/LoadingSpinner';
import { MapCard } from './MapCard';
import { MapForm } from './MapForm';

export const MapManagementPage: React.FC = () => {
  const { data: maps = [], isLoading, error } = useMaps();
  const { isAdmin } = useAuth();
  const { showMapForm, showMapFormModal, hideMapFormModal } = useUIStore();

  if (isLoading) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <LoadingSpinner size="lg" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <div className="text-center">
          <p className="text-red-600 mb-4">Failed to load maps</p>
          <Button onClick={() => window.location.reload()}>
            Retry
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex-1 p-6">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Marina Maps</h1>
            <p className="text-gray-600 mt-1">
              Manage your marina property maps and boat layouts
            </p>
          </div>
          
          {isAdmin && (
            <Button onClick={showMapFormModal}>
              <svg className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
              </svg>
              Add New Map
            </Button>
          )}
        </div>

        {/* Maps Grid */}
        {maps.length === 0 ? (
          <div className="text-center py-12">
            <svg className="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
            </svg>
            <h3 className="text-lg font-medium text-gray-900 mb-2">No maps found</h3>
            <p className="text-gray-500 mb-4">
              {isAdmin 
                ? "Get started by creating your first marina map" 
                : "No maps have been created yet"
              }
            </p>
            {isAdmin && (
              <Button onClick={showMapFormModal}>
                Create Your First Map
              </Button>
            )}
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {maps.map((map) => (
              <MapCard key={map.id} map={map} />
            ))}
          </div>
        )}

        {/* Map Form Modal */}
        <MapForm />
      </div>
    </div>
  );
};




// frontend/src/components/map/MapCard.tsx
// frontend/src/components/map/MapCard.tsx
import React from 'react';
import { Map } from '../../types/map';
import { useMapStore } from '../../stores/mapStore';
import { useUIStore } from '../../stores/uiStore';
import { useAuth } from '../../hooks/useAuth';
import { useDeleteMap } from '../../hooks/useMaps';
import { Button } from '../common/Button';

interface MapCardProps {
  map: Map;
}

export const MapCard: React.FC<MapCardProps> = ({ map }) => {
  const { selectedMapId, setCurrentMap } = useMapStore();
  const { showConfirm } = useUIStore();
  const { isAdmin } = useAuth();
  const deleteMap = useDeleteMap();

  const isSelected = selectedMapId === map.id;

  const handleSelect = () => {
    setCurrentMap(map.id);
    // Navigate back to main map view
    window.history.back();
  };

  const handleEdit = () => {
    // TODO: Set selected map for editing and show form
    console.log('Edit map:', map.id);
  };

  const handleDelete = () => {
    showConfirm({
      title: 'Delete Map',
      message: `Are you sure you want to delete "${map.name}"? This will also delete all boat positions on this map.`,
      onConfirm: () => {
        deleteMap.mutate(map.id);
      },
      onCancel: () => {},
    });
  };

  const handleToggleActive = () => {
    // TODO: Toggle map active status
    console.log('Toggle active:', map.id);
  };

  return (
    <div className={`
      bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow
      ${isSelected ? 'ring-2 ring-blue-500' : ''}
      ${!map.is_active ? 'opacity-75' : ''}
    `}>
      {/* Map Preview */}
      <div className="aspect-video bg-gray-100 relative">
        <img
          src={`/assets/maps/${map.image_path}`}
          alt={map.name}
          className="w-full h-full object-cover"
          onError={(e) => {
            e.currentTarget.src = '/assets/placeholder-map.png';
          }}
        />
        
        {/* Status Badge */}
        <div className="absolute top-3 right-3">
          <span className={`
            px-2 py-1 text-xs font-medium rounded-full
            ${map.is_active 
              ? 'bg-green-100 text-green-800' 
              : 'bg-gray-100 text-gray-800'
            }
          `}>
            {map.is_active ? 'Active' : 'Inactive'}
          </span>
        </div>

        {/* Selected Badge */}
        {isSelected && (
          <div className="absolute top-3 left-3">
            <span className="px-2 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-800">
              Current
            </span>
          </div>
        )}
      </div>

      {/* Map Info */}
      <div className="p-4">
        <h3 className="text-lg font-semibold text-gray-900 mb-1">
          {map.name}
        </h3>
        
        {map.description && (
          <p className="text-gray-600 text-sm mb-3 line-clamp-2">
            {map.description}
          </p>
        )}

        <div className="flex items-center justify-between text-sm text-gray-500 mb-4">
          <span>{map.boat_count || 0} boats</span>
          <span>{map.image_width} × {map.image_height}</span>
        </div>

        {/* Actions */}
        <div className="flex space-x-2">
          <Button
            onClick={handleSelect}
            variant={isSelected ? "secondary" : "primary"}
            size="sm"
            className="flex-1"
          >
            {isSelected ? 'Current Map' : 'Select Map'}
          </Button>

          {isAdmin && (
            <div className="flex space-x-1">
              <Button
                onClick={handleEdit}
                variant="ghost"
                size="sm"
                title="Edit map"
              >
                <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
              </Button>
              
              <Button
                onClick={handleToggleActive}
                variant="ghost"
                size="sm"
                title={map.is_active ? "Deactivate map" : "Activate map"}
              >
                <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
              </Button>
              
              <Button
                onClick={handleDelete}
                variant="ghost"
                size="sm"
                title="Delete map"
                className="text-red-600 hover:text-red-700"
              >
                <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
              </Button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

// frontend/src/components/map/MapControls.tsx
// frontend/src/components/map/MapControls.tsx
import React from 'react';
import { useUIStore } from '../../stores/uiStore';
import { Button } from '../common/Button';

export const MapControls: React.FC = () => {
  const { mapZoom, setMapZoom, isMapInteractive, setMapInteractive } = useUIStore();

  const handleZoomIn = () => {
    setMapZoom(mapZoom * 1.2);
  };

  const handleZoomOut = () => {
    setMapZoom(mapZoom / 1.2);
  };

  const handleResetZoom = () => {
    setMapZoom(1);
  };

  return (
    <div className="absolute bottom-4 right-4 bg-white rounded-lg shadow-lg p-2 space-y-1">
      <Button
        size="sm"
        variant="ghost"
        onClick={handleZoomIn}
        title="Zoom In"
      >
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
        </svg>
      </Button>
      
      <Button
        size="sm"
        variant="ghost"
        onClick={handleResetZoom}
        title={`Current zoom: ${Math.round(mapZoom * 100)}%`}
        className="text-xs"
      >
        {Math.round(mapZoom * 100)}%
      </Button>
      
      <Button
        size="sm"
        variant="ghost"
        onClick={handleZoomOut}
        title="Zoom Out"
      >
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" />
        </svg>
      </Button>
      
      <div className="border-t pt-1">
        <Button
          size="sm"
          variant={isMapInteractive ? "primary" : "secondary"}
          onClick={() => setMapInteractive(!isMapInteractive)}
          title={isMapInteractive ? "Disable interaction" : "Enable interaction"}
        >
          <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
          </svg>
        </Button>
      </div>
    </div>
  );
};

// frontend/src/components/map/MapCanvas.tsx
// frontend/src/components/map/MapCanvas.tsx
import React, { useRef, useEffect, useState } from 'react';
import { Stage, Layer, Image as KonvaImage } from 'react-konva';
import { useMapStore } from '../../stores/mapStore';
import { useUIStore } from '../../stores/uiStore';
import { BoatObject } from './BoatObject';
import { MapToolbar } from './MapToolbar';
import { LoadingSpinner } from '../common/LoadingSpinner';
import useImage from 'use-image';
import Konva from 'konva';

export const MapCanvas: React.FC = () => {
  const { currentMap, isLoading } = useMapStore();
  const { sidebarOpen, sidebarWidth, selectedPositionId, setSelectedPosition } = useUIStore();
  const stageRef = useRef<Konva.Stage>(null);
  const [stageDimensions, setStageDimensions] = useState({ width: 800, height: 600 });
  
  // Load map image
  const [mapImage] = useImage(
    currentMap ? `/assets/maps/${currentMap.map.image_path}` : '',
    'anonymous'
  );

  // Calculate stage dimensions based on sidebar state
  useEffect(() => {
    const updateDimensions = () => {
      const sidebar = sidebarOpen ? sidebarWidth : 0;
      const width = window.innerWidth - sidebar;
      const height = window.innerHeight - 64; // Subtract navbar height
      
      setStageDimensions({ width, height });
    };

    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, [sidebarOpen, sidebarWidth]);

  // Handle keyboard controls for selected boat
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (!selectedPositionId || !currentMap) return;
      
      // Ignore if user is typing in an input
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      const selectedBoat = currentMap.boats.find(
        boat => boat.position.id === selectedPositionId
      );
      
      if (!selectedBoat) return;

      const position = selectedBoat.position;
      const speed = 5;
      
      let updates: Partial<typeof position> = {};
      
      switch (e.key.toLowerCase()) {
        case 'w':
        case 'arrowup':
          updates.y = Math.max(0, position.y - speed);
          break;
        case 's':
        case 'arrowdown':
          updates.y = Math.min(currentMap.map.image_height, position.y + speed);
          break;
        case 'a':
        case 'arrowleft':
          updates.x = Math.max(0, position.x - speed);
          break;
        case 'd':
        case 'arrowright':
          updates.x = Math.min(currentMap.map.image_width, position.x + speed);
          break;
        case '[':
          updates.rotation = position.rotation - 5;
          break;
        case ']':
          updates.rotation = position.rotation + 5;
          break;
        case '=':
        case '+':
          updates.width = position.width + 5;
          updates.height = position.height + 3.5;
          break;
        case '-':
          updates.width = Math.max(10, position.width - 5);
          updates.height = Math.max(7, position.height - 3.5);
          break;
        default:
          return;
      }

      if (Object.keys(updates).length > 0) {
        e.preventDefault();
        // TODO: Call update position mutation
        console.log('Updating position:', updates);
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [selectedPositionId, currentMap]);

  const handleStageClick = (e: Konva.KonvaEventObject<MouseEvent>) => {
    // Deselect if clicking on empty area
    if (e.target === e.target.getStage()) {
      setSelectedPosition(null);
    }
  };

  const handleDoubleClick = (e: Konva.KonvaEventObject<MouseEvent>) => {
    if (e.target === e.target.getStage() && currentMap) {
      // Create new boat position at click location
      const pos = e.target.getStage()?.getPointerPosition();
      if (pos) {
        // TODO: Call create position mutation
        console.log('Creating new position at:', pos);
      }
    }
  };

  if (isLoading) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <LoadingSpinner size="lg" />
      </div>
    );
  }

  if (!currentMap) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <div className="text-center">
          <p className="text-gray-500 mb-4">No map selected</p>
          <p className="text-sm text-gray-400">
            Select a map from the dropdown above
          </p>
        </div>
      </div>
    );
  }

  // Calculate scale to fit map in viewport
  const scaleX = stageDimensions.width / currentMap.map.image_width;
  const scaleY = stageDimensions.height / currentMap.map.image_height;
  const scale = Math.min(scaleX, scaleY, 1); // Don't scale up

  return (
    <div className="flex-1 relative overflow-hidden bg-gray-100">
      <MapToolbar />
      
      <Stage
        ref={stageRef}
        width={stageDimensions.width}
        height={stageDimensions.height}
        scaleX={scale}
        scaleY={scale}
        onClick={handleStageClick}
        onDblClick={handleDoubleClick}
        className="cursor-crosshair"
      >
        <Layer>
          {/* Map background */}
          {mapImage && (
            <KonvaImage
              image={mapImage}
              width={currentMap.map.image_width}
              height={currentMap.map.image_height}
            />
          )}
          
          {/* Boat objects */}
          {currentMap.boats.map((boatWithPosition) => (
            <BoatObject
              key={boatWithPosition.position.id}
              boatWithPosition={boatWithPosition}
              isSelected={selectedPositionId === boatWithPosition.position.id}
              onSelect={() => setSelectedPosition(boatWithPosition.position.id)}
            />
          ))}
        </Layer>
      </Stage>
      
      {/* Map info overlay */}
      <div className="absolute top-4 left-4 bg-white bg-opacity-90 rounded-lg p-3 shadow-md">
        <h3 className="font-semibold text-gray-900">{currentMap.map.name}</h3>
        <p className="text-sm text-gray-600">
          {currentMap.boats.length} positions
        </p>
        {selectedPositionId && (
          <p className="text-xs text-blue-600 mt-1">
            Use WASD or arrow keys to move selected boat
          </p>
        )}
      </div>
    </div>
  );
};



// frontend/src/components/map/MapToolbar.tsx
// frontend/src/components/map/MapToolbar.tsx
import React from 'react';
import { useMapStore } from '../../stores/mapStore';
import { useUIStore } from '../../stores/uiStore';
import { Button } from '../common/Button';

export const MapToolbar: React.FC = () => {
  const { currentMap } = useMapStore();
  const { 
    selectedPositionId, 
    setSelectedPosition, 
    showBoatFormModal,
    showConfirm 
  } = useUIStore();

  const handleAddBoat = () => {
    if (!currentMap) return;
    
    // TODO: Create new position at center of map
    console.log('Adding new boat');
  };

  const handleDeletePosition = () => {
    if (!selectedPositionId) return;
    
    showConfirm({
      title: 'Delete Position',
      message: 'Are you sure you want to delete this boat position? This action cannot be undone.',
      onConfirm: () => {
        // TODO: Call delete position mutation
        console.log('Deleting position:', selectedPositionId);
        setSelectedPosition(null);
      },
      onCancel: () => {},
    });
  };

  if (!currentMap) return null;

  const selectedBoat = selectedPositionId 
    ? currentMap.boats.find(b => b.position.id === selectedPositionId)
    : null;

  return (
    <div className="absolute top-4 right-4 bg-white rounded-lg shadow-lg p-3 space-y-2 z-10">
      <div className="flex space-x-2">
        <Button
          size="sm"
          onClick={handleAddBoat}
          title="Add new boat position (or double-click on map)"
        >
          <svg className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
          </svg>
          Add Boat
        </Button>
        
        <Button
          size="sm"
          variant="secondary"
          onClick={showBoatFormModal}
        >
          <svg className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
          </svg>
          Add Listing
        </Button>
      </div>

      {selectedBoat && (
        <div className="border-t pt-2 space-y-2">
          <div className="text-xs text-gray-600">
            Selected: {selectedBoat.boat?.name || `Position #${selectedBoat.position.id}`}
          </div>
          
          <div className="flex space-x-1">
            <Button
              size="sm"
              variant="secondary"
              onClick={() => {/* TODO: Show boat details */}}
            >
              Details
            </Button>
            
            <Button
              size="sm"
              variant="danger"
              onClick={handleDeletePosition}
            >
              Delete
            </Button>
          </div>
          
          <div className="text-xs text-gray-500 bg-gray-50 p-2 rounded">
            <div>WASD: Move</div>
            <div>[] : Rotate</div>
            <div>+/-: Resize</div>
          </div>
        </div>
      )}
    </div>
  );
};



// frontend/src/components/map/BoatObject.tsx
// frontend/src/components/map/BoatObject.tsx
import React, { useState } from 'react';
import { Ellipse, Text, Group } from 'react-konva';
import { BoatWithPosition } from '../../types/boat';
import Konva from 'konva';

interface BoatObjectProps {
  boatWithPosition: BoatWithPosition;
  isSelected: boolean;
  onSelect: () => void;
}

export const BoatObject: React.FC<BoatObjectProps> = ({
  boatWithPosition,
  isSelected,
  onSelect,
}) => {
  const { boat, position } = boatWithPosition;
  const [isDragging, setIsDragging] = useState(false);

  const handleDragStart = () => {
    setIsDragging(true);
    onSelect();
  };

  const handleDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    setIsDragging(false);
    
    const newX = e.target.x();
    const newY = e.target.y();
    
    // TODO: Call update position mutation
    console.log('Position updated:', { id: position.id, x: newX, y: newY });
  };

  const getBoatColor = () => {
    if (isSelected) return '#3B82F6'; // Blue when selected
    if (!boat) return '#9CA3AF'; // Gray when unassigned
    return position.color;
  };

  const getStrokeWidth = () => {
    if (isSelected) return 3;
    if (isDragging) return 2;
    return position.stroke_width;
  };

  return (
    <Group
      x={position.x}
      y={position.y}
      rotation={position.rotation}
      draggable
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      onClick={onSelect}
      onTap={onSelect}
    >
      {/* Boat shape */}
      <Ellipse
        width={position.width}
        height={position.height}
        fill={getBoatColor()}
        stroke={position.stroke_color}
        strokeWidth={getStrokeWidth()}
        opacity={position.is_visible ? (isDragging ? 0.8 : 1) : 0.3}
        shadowColor="black"
        shadowBlur={isSelected ? 10 : 0}
        shadowOpacity={0.3}
      />
      
      {/* Boat index/name label */}
      {boat && (
        <Text
          text={boat.name || `#${boat.index}`}
          fontSize={Math.min(position.width / 4, 14)}
          fontFamily="Arial"
          fill="white"
          align="center"
          verticalAlign="middle"
          width={position.width}
          height={position.height}
          offsetX={position.width / 2}
          offsetY={position.height / 2}
          listening={false}
        />
      )}
      
      {/* Selection indicator */}
      {isSelected && (
        <Ellipse
          width={position.width + 10}
          height={position.height + 10}
          stroke="#3B82F6"
          strokeWidth={2}
          dash={[5, 5]}
          offsetX={5}
          offsetY={5}
          listening={false}
        />
      )}
    </Group>
  );
};



// frontend/src/components/map/MapForm.tsx
// frontend/src/components/map/MapForm.tsx
import React, { useState, useEffect } from 'react';
import { Map, MapCreate, MapUpdate } from '../../types/map';
import { useCreateMap, useUpdateMap } from '../../hooks/useMaps';
import { useUIStore } from '../../stores/uiStore';
import { Modal } from '../common/Modal';
import { Button } from '../common/Button';
import { FileUpload } from '../common/FileUpload';

interface MapFormProps {
  map?: Map;
}

export const MapForm: React.FC<MapFormProps> = ({ map }) => {
  const { showMapForm, hideMapFormModal } = useUIStore();
  const createMap = useCreateMap();
  const updateMap = useUpdateMap();
  
  const [formData, setFormData] = useState<MapCreate>({
    name: '',
    description: '',
    image_path: '',
    image_width: 794,
    image_height: 1123,
    is_active: true,
  });
  
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // Load map data when editing
  useEffect(() => {
    if (map) {
      setFormData({
        name: map.name,
        description: map.description || '',
        image_path: map.image_path,
        image_width: map.image_width,
        image_height: map.image_height,
        is_active: map.is_active,
      });
    } else {
      // Reset form for new map
      setFormData({
        name: '',
        description: '',
        image_path: '',
        image_width: 794,
        image_height: 1123,
        is_active: true,
      });
      setUploadedFile(null);
    }
    setErrors({});
  }, [map]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    const checked = (e.target as HTMLInputElement).checked;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleFileUpload = (file: File) => {
    setUploadedFile(file);
    
    // Create a preview and try to get dimensions
    const img = new Image();
    img.onload = () => {
      setFormData(prev => ({
        ...prev,
        image_width: img.naturalWidth,
        image_height: img.naturalHeight,
        image_path: file.name
      }));
    };
    img.src = URL.createObjectURL(file);
  };

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.name.trim()) {
      newErrors.name = 'Map name is required';
    }
    
    if (!map && !uploadedFile) {
      newErrors.image_path = 'Map image is required';
    }
    
    if (formData.image_width <= 0) {
      newErrors.image_width = 'Width must be greater than 0';
    }
    
    if (formData.image_height <= 0) {
      newErrors.image_height = 'Height must be greater than 0';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;

    try {
      // TODO: Handle file upload to server first if there's an uploaded file
      // For now, we'll just use the filename
      
      if (map) {
        await updateMap.mutateAsync({
          id: map.id,
          data: formData as MapUpdate
        });
      } else {
        await createMap.mutateAsync(formData);
      }
      
      hideMapFormModal();
    } catch (error) {
      console.error('Form submission error:', error);
    }
  };

  const isLoading = createMap.isPending || updateMap.isPending;

  return (
    <Modal
      isOpen={showMapForm}
      onClose={hideMapFormModal}
      title={map ? 'Edit Map' : 'Add New Map'}
      size="lg"
    >
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Basic Info */}
        <div className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700 mb-1">
              Map Name *
            </label>
            <input
              id="name"
              name="name"
              type="text"
              value={formData.name}
              onChange={handleChange}
              placeholder="e.g., Pier 11 Marina"
              className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                errors.name ? 'border-red-300' : 'border-gray-300'
              }`}
              disabled={isLoading}
            />
            {errors.name && <p className="text-red-600 text-sm mt-1">{errors.name}</p>}
          </div>
          
          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-1">
              Description
            </label>
            <textarea
              id="description"
              name="description"
              rows={3}
              value={formData.description}
              onChange={handleChange}
              placeholder="Optional description of this marina property..."
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isLoading}
            />
          </div>
        </div>

        {/* Image Upload */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Marina Layout Image {!map && '*'}
          </label>
          <FileUpload
            onFileSelect={handleFileUpload}
            acceptedTypes={['image/jpeg', 'image/png', 'image/gif']}
            maxSize={10 * 1024 * 1024} // 10MB
            disabled={isLoading}
          />
          {errors.image_path && <p className="text-red-600 text-sm mt-1">{errors.image_path}</p>}
          
          {(uploadedFile || map) && (
            <div className="mt-2 p-3 bg-gray-50 rounded-md">
              <p className="text-sm text-gray-600">
                Current image: {uploadedFile?.name || formData.image_path}
              </p>
            </div>
          )}
        </div>

        {/* Dimensions */}
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label htmlFor="image_width" className="block text-sm font-medium text-gray-700 mb-1">
              Width (px) *
            </label>
            <input
              id="image_width"
              name="image_width"
              type="number"
              min="1"
              value={formData.image_width}
              onChange={handleChange}
              className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                errors.image_width ? 'border-red-300' : 'border-gray-300'
              }`}
              disabled={isLoading}
            />
            {errors.image_width && <p className="text-red-600 text-sm mt-1">{errors.image_width}</p>}
          </div>
          
          <div>
            <label htmlFor="image_height" className="block text-sm font-medium text-gray-700 mb-1">
              Height (px) *
            </label>
            <input
              id="image_height"
              name="image_height"
              type="number"
              min="1"
              value={formData.image_height}
              onChange={handleChange}
              className={`w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                errors.image_height ? 'border-red-300' : 'border-gray-300'
              }`}
              disabled={isLoading}
            />
            {errors.image_height && <p className="text-red-600 text-sm mt-1">{errors.image_height}</p>}
          </div>
        </div>

        {/* Settings */}
        <div className="flex items-center">
          <input
            id="is_active"
            name="is_active"
            type="checkbox"
            checked={formData.is_active}
            onChange={handleChange}
            className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
            disabled={isLoading}
          />
          <label htmlFor="is_active" className="ml-2 block text-sm text-gray-900">
            Map is active (available for selection)
          </label>
        </div>

        {/* Form Actions */}
        <div className="flex justify-end space-x-3 pt-4 border-t">
          <Button
            type="button"
            variant="secondary"
            onClick={hideMapFormModal}
            disabled={isLoading}
          >
            Cancel
          </Button>
          <Button
            type="submit"
            isLoading={isLoading}
          >
            {map ? 'Update Map' : 'Create Map'}
          </Button>
        </div>
      </form>
    </Modal>
  );
};

// frontend/src/hooks/useAuth.ts
// frontend/src/hooks/useAuth.ts
import { useEffect } from 'react';
import { useAuthStore } from '../stores/authStore';

export const useAuth = () => {
  const { 
    user, 
    isAuthenticated, 
    isLoading, 
    error, 
    login, 
    logout, 
    loadUser, 
    clearError 
  } = useAuthStore();

  useEffect(() => {
    loadUser();
  }, [loadUser]);

  return {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    logout,
    clearError,
    isAdmin: user?.role === 'admin',
    isStaff: user?.role === 'staff',
  };
};



// frontend/src/hooks/useMaps.ts
// frontend/src/hooks/useMaps.ts (Updated with additional mutations)
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { MapService } from '../services/maps';
import { MapCreate, MapUpdate } from '../types/map';

export const useMaps = () => {
  return useQuery({
    queryKey: ['maps'],
    queryFn: () => MapService.getMaps({ active_only: true }),
    staleTime: 1000 * 60 * 10, // 10 minutes
  });
};

export const useMap = (id: number) => {
  return useQuery({
    queryKey: ['map', id],
    queryFn: () => MapService.getMap(id),
    enabled: !!id,
  });
};

export const useMapWithBoats = (id: number) => {
  return useQuery({
    queryKey: ['mapWithBoats', id],
    queryFn: () => MapService.getMapWithBoats(id),
    enabled: !!id,
    staleTime: 1000 * 60 * 2, // 2 minutes (shorter for real-time data)
  });
};

export const useCreateMap = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (mapData: MapCreate) => MapService.createMap(mapData),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['maps'] });
    },
  });
};

export const useUpdateMap = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }: { id: number; data: MapUpdate }) => 
      MapService.updateMap(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['map', id] });
      queryClient.invalidateQueries({ queryKey: ['maps'] });
      queryClient.invalidateQueries({ queryKey: ['mapWithBoats', id] });
    },
  });
};

export const useDeleteMap = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id: number) => MapService.deleteMap(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['maps'] });
    },
  });
};

// frontend/src/hooks/useDebounce.ts
// frontend/src/hooks/useDebounce.ts
import { useState, useEffect } from 'react';

export const useDebounce = <T>(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

// frontend/src/hooks/useBoats.ts
// frontend/src/hooks/useBoats.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { BoatService } from '../services/boats';
import { BoatListing, BoatListingCreate, BoatListingUpdate, BoatSearchParams } from '../types/boat';

export const useBoats = (params?: BoatSearchParams) => {
  return useQuery({
    queryKey: ['boats', params],
    queryFn: () => BoatService.getBoats(params),
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
};

export const useBoat = (id: number) => {
  return useQuery({
    queryKey: ['boat', id],
    queryFn: () => BoatService.getBoat(id),
    enabled: !!id,
  });
};

export const useCreateBoat = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (boatData: BoatListingCreate) => BoatService.createBoat(boatData),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['boats'] });
    },
  });
};

export const useUpdateBoat = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }: { id: number; data: BoatListingUpdate }) => 
      BoatService.updateBoat(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['boat', id] });
      queryClient.invalidateQueries({ queryKey: ['boats'] });
    },
  });
};

export const useDeleteBoat = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id: number) => BoatService.deleteBoat(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['boats'] });
    },
  });
};

export const useAssignBoat = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ boatId, positionId }: { boatId: number; positionId: number }) =>
      BoatService.assignBoatToPosition(boatId, positionId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['boats'] });
      queryClient.invalidateQueries({ queryKey: ['maps'] });
    },
  });
};



// frontend/src/services/api.ts
// frontend/src/services/api.ts
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1';

class ApiClient {
  private baseURL: string;
  private token: string | null = null;

  constructor(baseURL: string = API_BASE_URL) {
    this.baseURL = baseURL;
    this.loadToken();
  }

  private loadToken(): void {
    this.token = localStorage.getItem('access_token');
  }

  setToken(token: string): void {
    this.token = token;
    localStorage.setItem('access_token', token);
  }

  clearToken(): void {
    this.token = null;
    localStorage.removeItem('access_token');
  }

  private getHeaders(): HeadersInit {
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
    };

    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    }

    return headers;
  }

  private async handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
      const error = await response.json().catch(() => ({
        detail: 'An error occurred',
        status_code: response.status
      }));
      throw new ApiError(error.detail, response.status);
    }

    return response.json();
  }

  async get<T>(endpoint: string, params?: Record<string, any>): Promise<T> {
    const url = new URL(`${this.baseURL}${endpoint}`);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, value.toString());
        }
      });
    }

    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: this.getHeaders(),
    });

    return this.handleResponse<T>(response);
  }

  async post<T>(endpoint: string, data?: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers: this.getHeaders(),
      body: data ? JSON.stringify(data) : undefined,
    });

    return this.handleResponse<T>(response);
  }

  async put<T>(endpoint: string, data?: any): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'PUT',
      headers: this.getHeaders(),
      body: data ? JSON.stringify(data) : undefined,
    });

    return this.handleResponse<T>(response);
  }

  async delete<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'DELETE',
      headers: this.getHeaders(),
    });

    return this.handleResponse<T>(response);
  }

  // Form data for login endpoint
  async postForm<T>(endpoint: string, data: FormData): Promise<T> {
    const headers: HeadersInit = {};
    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    }

    const response = await fetch(`${this.baseURL}${endpoint}`, {
      method: 'POST',
      headers,
      body: data,
    });

    return this.handleResponse<T>(response);
  }
}

export class ApiError extends Error {
  constructor(public message: string, public status: number) {
    super(message);
    this.name = 'ApiError';
  }
}

export const apiClient = new ApiClient();



// frontend/src/services/positions.ts
// frontend/src/services/positions.ts
import { apiClient } from './api';
import {
  BoatPosition,
  BoatPositionCreate,
  BoatPositionUpdate
} from '../types/boat';

export class PositionService {
  static async getPositionsByMap(mapId: number): Promise<BoatPosition[]> {
    return apiClient.get<BoatPosition[]>(`/positions/map/${mapId}`);
  }

  static async getPosition(id: number): Promise<BoatPosition> {
    return apiClient.get<BoatPosition>(`/positions/${id}`);
  }

  static async createPosition(positionData: BoatPositionCreate): Promise<BoatPosition> {
    return apiClient.post<BoatPosition>('/positions', positionData);
  }

  static async updatePosition(id: number, positionData: BoatPositionUpdate): Promise<BoatPosition> {
    return apiClient.put<BoatPosition>(`/positions/${id}`, positionData);
  }

  static async deletePosition(id: number): Promise<{ message: string }> {
    return apiClient.delete(`/positions/${id}`);
  }
}

// frontend/src/services/boats.ts
// frontend/src/services/boats.ts
import { apiClient } from './api';
import {
  BoatListing,
  BoatListingCreate,
  BoatListingUpdate,
  BoatSearchParams
} from '../types/boat';

export class BoatService {
  static async getBoats(params?: BoatSearchParams): Promise<BoatListing[]> {
    return apiClient.get<BoatListing[]>('/boats', params);
  }

  static async getBoat(id: number): Promise<BoatListing> {
    return apiClient.get<BoatListing>(`/boats/${id}`);
  }

  static async getBoatByIndex(index: number): Promise<BoatListing> {
    return apiClient.get<BoatListing>(`/boats/index/${index}`);
  }

  static async createBoat(boatData: BoatListingCreate): Promise<BoatListing> {
    return apiClient.post<BoatListing>('/boats', boatData);
  }

  static async updateBoat(id: number, boatData: BoatListingUpdate): Promise<BoatListing> {
    return apiClient.put<BoatListing>(`/boats/${id}`, boatData);
  }

  static async deleteBoat(id: number): Promise<{ message: string }> {
    return apiClient.delete(`/boats/${id}`);
  }

  static async assignBoatToPosition(boatId: number, positionId: number): Promise<BoatListing> {
    return apiClient.post<BoatListing>(`/boats/${boatId}/assign/${positionId}`);
  }

  static async unassignBoat(boatId: number): Promise<BoatListing> {
    return apiClient.post<BoatListing>(`/boats/${boatId}/unassign`);
  }
}



// frontend/src/services/maps.ts
// frontend/src/services/maps.ts
import { apiClient } from './api';
import { Map, MapCreate, MapUpdate, MapWithBoats } from '../types/map';
import { PaginationParams } from '../types/api';

export interface MapSearchParams extends PaginationParams {
  active_only?: boolean;
}

export class MapService {
  static async getMaps(params?: MapSearchParams): Promise<Map[]> {
    return apiClient.get<Map[]>('/maps', params);
  }

  static async getMap(id: number): Promise<Map> {
    return apiClient.get<Map>(`/maps/${id}`);
  }

  static async getMapWithBoats(id: number): Promise<MapWithBoats> {
    return apiClient.get<MapWithBoats>(`/maps/${id}`);
  }

  static async createMap(mapData: MapCreate): Promise<Map> {
    return apiClient.post<Map>('/maps', mapData);
  }

  static async updateMap(id: number, mapData: MapUpdate): Promise<Map> {
    return apiClient.put<Map>(`/maps/${id}`, mapData);
  }

  static async deleteMap(id: number): Promise<{ message: string }> {
    return apiClient.delete(`/maps/${id}`);
  }
}



// frontend/src/services/auth.ts
// frontend/src/services/auth.ts
import { apiClient, ApiError } from './api';
import { User, LoginCredentials, AuthToken, UserCreate, UserUpdate } from '../types/user';

export class AuthService {
  static async login(credentials: LoginCredentials): Promise<AuthToken> {
    const formData = new FormData();
    formData.append('username', credentials.username);
    formData.append('password', credentials.password);

    const token = await apiClient.postForm<AuthToken>('/auth/login', formData);
    apiClient.setToken(token.access_token);
    return token;
  }

  static async logout(): Promise<void> {
    apiClient.clearToken();
  }

  static async getCurrentUser(): Promise<User | null> {
    try {
      return await apiClient.get<User>('/auth/me');
    } catch (error) {
      if (error instanceof ApiError && error.status === 401) {
        this.logout();
        return null;
      }
      throw error;
    }
  }

  static async createUser(userData: UserCreate): Promise<User> {
    return apiClient.post<User>('/auth/register', userData);
  }

  static async updateUser(userId: number, userData: UserUpdate): Promise<User> {
    return apiClient.put<User>(`/auth/users/${userId}`, userData);
  }

  static isAuthenticated(): boolean {
    return !!localStorage.getItem('access_token');
  }
}



# backend/conftest.py
# backend/conftest.py
import pytest
from typing import Generator
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient
from app.main import app
from app.core.database import get_db, Base
from app.core.config import settings
from app.models.user import User, UserRole
from app.services.auth import AuthService
from app.schemas.user import UserCreate

# Use in-memory SQLite for testing
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def override_get_db():
    """Override database dependency for testing"""
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

app.dependency_overrides[get_db] = override_get_db

@pytest.fixture(scope="session")
def db() -> Generator:
    """Create test database"""
    Base.metadata.create_all(bind=engine)
    yield TestingSessionLocal()
    Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="module")
def client() -> Generator:
    """Create test client"""
    with TestClient(app) as c:
        yield c

@pytest.fixture
def admin_user(db) -> User:
    """Create admin user for testing"""
    user_create = UserCreate(
        email="admin@pier11marina.com",
        full_name="Admin User",
        password="AdminPass123!",
        role=UserRole.ADMIN
    )
    return AuthService.create_user(db, user_create)

@pytest.fixture
def staff_user(db) -> User:
    """Create staff user for testing"""
    user_create = UserCreate(
        email="staff@pier11marina.com",
        full_name="Staff User",
        password="StaffPass123!",
        role=UserRole.STAFF
    )
    return AuthService.create_user(db, user_create)

@pytest.fixture
def admin_headers(client, admin_user) -> dict:
    """Get admin authentication headers"""
    response = client.post(
        "/api/v1/auth/login",
        data={"username": admin_user.email, "password": "AdminPass123!"}
    )
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}

@pytest.fixture
def staff_headers(client, staff_user) -> dict:
    """Get staff authentication headers"""
    response = client.post(
        "/api/v1/auth/login",
        data={"username": staff_user.email, "password": "StaffPass123!"}
    )
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}



# backend/pytest.ini
# backend/pytest.ini
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --strict-config
    --cov=app
    --cov-report=term-missing
    --cov-report=html
    --cov-report=xml
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests



# backend/requirements.txt
# backend/requirements.txt
# FastAPI and dependencies
fastapi==0.104.1
uvicorn[standard]==0.24.0

# Database
sqlalchemy==2.0.23
alembic==1.12.1
psycopg2-binary==2.9.9

# Authentication & Security
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6

# Validation
pydantic==2.5.0
pydantic-settings==2.1.0
email-validator==2.1.0

# Testing
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
httpx==0.25.2

# Development
black==23.11.0
isort==5.12.0
flake8==6.1.0
mypy==1.7.1

# backend/alembic.ini
# A generic, single database configuration.

[alembic]
# path to migration scripts
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python-dateutil library that can be
# installed by adding `alembic[tz]` to the pip requirements
# string value is passed to dateutil.tz.gettz()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = postgresql://pier11:password@localhost/pier11_marina


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


# backend/app/main.py
# backend/app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from .core.config import settings
from .core.database import engine
from .models import Base
from .api.v1 import api_router

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.VERSION,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Set up CORS
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# Add trusted host middleware for security
app.add_middleware(
    TrustedHostMiddleware, 
    allowed_hosts=["localhost", "127.0.0.1"]
)

# Include API router
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/")
def root():
    """Health check endpoint"""
    return {
        "message": "Pier 11 Marina Interactive Map API",
        "version": settings.VERSION,
        "status": "healthy"
    }

@app.get("/health")
def health_check():
    """Detailed health check"""
    return {
        "status": "healthy",
        "version": settings.VERSION,
        "api_prefix": settings.API_V1_STR
    }

# backend/app/core/config.py
# backend/app/core/config.py
from pydantic_settings import BaseSettings
from typing import Optional
import secrets

class Settings(BaseSettings):
    PROJECT_NAME: str = "Pier 11 Marina Interactive Map"
    VERSION: str = "2.0.0"
    API_V1_STR: str = "/api/v1"
    
    # Database
    DATABASE_URL: str = "postgresql://pier11:password@localhost/pier11_marina"
    
    # Security
    SECRET_KEY: str = secrets.token_urlsafe(32)
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 30  # 30 days
    
    # CORS
    BACKEND_CORS_ORIGINS: list[str] = ["http://localhost:3000", "http://localhost:5173"]
    
    # Environment
    DEBUG: bool = False
    TESTING: bool = False
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()



# backend/app/core/database.py
# backend/app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_recycle=300,
    echo=settings.DEBUG
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    """Database dependency for FastAPI"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()



# backend/app/core/security.py
# backend/app/core/security.py
from datetime import datetime, timedelta
from typing import Any, Union
from passlib.context import CryptContext
from jose import JWTError, jwt
from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = "HS256"

def create_access_token(
    subject: Union[str, Any], expires_delta: timedelta = None
) -> str:
    """Create JWT access token"""
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Union[str, None]:
    """Verify JWT token and return subject"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
        token_subject: str = payload.get("sub")
        return token_subject
    except JWTError:
        return None

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)

# backend/app/core/exceptions.py
# backend/app/core/exceptions.py
from fastapi import HTTPException, status

class BaseCustomException(HTTPException):
    def __init__(self, detail: str = None, headers: dict = None):
        super().__init__(
            status_code=self.status_code,
            detail=detail or self.detail,
            headers=headers
        )

class NotFoundError(BaseCustomException):
    status_code = status.HTTP_404_NOT_FOUND
    detail = "Resource not found"

class ValidationError(BaseCustomException):
    status_code = status.HTTP_422_UNPROCESSABLE_ENTITY
    detail = "Validation error"

class DuplicateError(BaseCustomException):
    status_code = status.HTTP_409_CONFLICT
    detail = "Resource already exists"

class UnauthorizedError(BaseCustomException):
    status_code = status.HTTP_401_UNAUTHORIZED
    detail = "Authentication required"

class ForbiddenError(BaseCustomException):
    status_code = status.HTTP_403_FORBIDDEN
    detail = "Insufficient permissions"



# backend/app/models/user.py
# backend/app/models/user.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum
from ..core.database import Base

class UserRole(str, enum.Enum):
    ADMIN = "admin"
    STAFF = "staff"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(Enum(UserRole), default=UserRole.STAFF, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    def __repr__(self):
        return f"<User(email='{self.email}', role='{self.role}')>"



# backend/app/models/__init__.py
# app/models/__init__.py
from ..core.database import Base
from .user import User
from .map import Map
from .boat_listing import BoatListing
from .boat_position import BoatPosition

__all__ = ["Base", "User", "Map", "BoatListing", "BoatPosition"]

# backend/app/models/boat_position.py
# backend/app/models/boat_position.py
from sqlalchemy import Column, Integer, Float, String, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class BoatPosition(Base):
    __tablename__ = "boat_positions"
    
    id = Column(Integer, primary_key=True, index=True)
    
    # Map relationship
    map_id = Column(Integer, ForeignKey("maps.id"), nullable=False, index=True)
    
    # Canvas coordinates and dimensions
    x = Column(Float, nullable=False, default=200.0)
    y = Column(Float, nullable=False, default=200.0)
    width = Column(Float, nullable=False, default=100.0)
    height = Column(Float, nullable=False, default=50.0)
    rotation = Column(Float, nullable=False, default=0.0)  # in degrees
    
    # Visual properties
    color = Column(String(50), nullable=False, default="blue")
    stroke_color = Column(String(50), nullable=False, default="black")
    stroke_width = Column(Float, nullable=False, default=1.0)
    
    # Metadata
    is_visible = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    map = relationship("Map", back_populates="boat_positions")
    boat_listing = relationship("BoatListing", back_populates="position", uselist=False)
    
    def __repr__(self):
        return f"<BoatPosition(id={self.id}, x={self.x}, y={self.y}, map_id={self.map_id})>"



# backend/app/models/map.py
# backend/app/models/map.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class Map(Base):
    __tablename__ = "maps"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)
    description = Column(Text)
    image_path = Column(String(255), nullable=False)
    image_width = Column(Integer, nullable=False, default=794)
    image_height = Column(Integer, nullable=False, default=1123)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    boat_positions = relationship("BoatPosition", back_populates="map", cascade="all, delete-orphan")
    
    def __repr__(self):
        return f"<Map(name='{self.name}', active={self.is_active})>"



# backend/app/models/boat_listing.py
# backend/app/models/boat_listing.py
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from ..core.database import Base

class BoatListing(Base):
    __tablename__ = "boat_listings"
    
    id = Column(Integer, primary_key=True, index=True)
    index = Column(Integer, unique=True, nullable=False, index=True)
    name = Column(String(100))
    customer_name = Column(String(100), nullable=False, index=True)
    size = Column(String(50))  # e.g., "35 ft"
    make_model = Column(String(100))
    vehicle_type = Column(String(50))  # boat, trailer, jetski, etc.
    section = Column(String(10))  # A, B, C, D, E, F
    notes = Column(Text)
    is_mapped = Column(Boolean, default=False, nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Foreign key to boat position (nullable for unmapped boats)
    position_id = Column(Integer, ForeignKey("boat_positions.id"), nullable=True, unique=True)
    
    # Relationships
    position = relationship("BoatPosition", back_populates="boat_listing", cascade="all, delete-orphan", single_parent=True)
    
    def __repr__(self):
        return f"<BoatListing(index={self.index}, name='{self.name}', customer='{self.customer_name}')>"



# backend/app/schemas/user.py
# backend/app/schemas/user.py
from pydantic import BaseModel, EmailStr, Field, validator
from typing import Optional
from datetime import datetime
from ..models.user import UserRole

class UserBase(BaseModel):
    email: EmailStr
    full_name: str = Field(..., min_length=1, max_length=100)
    role: UserRole = UserRole.STAFF
    is_active: bool = True

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, max_length=100)
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one digit')
        if not any(c.islower() for c in v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain at least one uppercase letter')
        return v

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    full_name: Optional[str] = Field(None, min_length=1, max_length=100)
    role: Optional[UserRole] = None
    is_active: Optional[bool] = None
    password: Optional[str] = Field(None, min_length=8, max_length=100)

class UserResponse(UserBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"

class TokenData(BaseModel):
    email: Optional[str] = None



# backend/app/schemas/__init__.py
from .user import UserCreate, UserUpdate, UserResponse, Token
from .map import MapCreate, MapUpdate, MapResponse
from .boat_listing import BoatListingCreate, BoatListingUpdate, BoatListingResponse
from .boat_position import BoatPositionCreate, BoatPositionUpdate, BoatPositionResponse
from .composite import BoatWithPosition, MapWithBoats

__all__ = [
    "UserCreate", "UserUpdate", "UserResponse", "Token",
    "MapCreate", "MapUpdate", "MapResponse", 
    "BoatListingCreate", "BoatListingUpdate", "BoatListingResponse",
    "BoatPositionCreate", "BoatPositionUpdate", "BoatPositionResponse",
    "BoatWithPosition", "MapWithBoats"
]

# backend/app/schemas/boat_position.py
# backend/app/schemas/boat_position.py
from pydantic import BaseModel, Field, validator
from typing import Optional, TYPE_CHECKING
from datetime import datetime

# Use TYPE_CHECKING to avoid circular imports
if TYPE_CHECKING:
    from .boat_listing import BoatListingResponse
    from .map import MapResponse

class BoatPositionBase(BaseModel):
    x: float = Field(default=200.0, ge=0)
    y: float = Field(default=200.0, ge=0)
    width: float = Field(default=100.0, gt=0)
    height: float = Field(default=50.0, gt=0)
    rotation: float = Field(default=0.0, ge=-360, le=360)
    color: str = Field(default="blue", max_length=50)
    stroke_color: str = Field(default="black", max_length=50)
    stroke_width: float = Field(default=1.0, gt=0)
    is_visible: bool = True

class BoatPositionCreate(BoatPositionBase):
    map_id: int = Field(..., gt=0)
    
    @validator('color', 'stroke_color')
    def validate_colors(cls, v):
        valid_colors = [
            'red', 'blue', 'green', 'yellow', 'orange', 'purple', 'pink',
            'brown', 'gray', 'black', 'white', 'navy', 'teal', 'lime',
            'maroon', 'olive', 'silver', 'aqua', 'fuchsia'
        ]
        if v.lower() not in valid_colors:
            raise ValueError(f'Color must be one of: {", ".join(valid_colors)}')
        return v.lower()

class BoatPositionUpdate(BaseModel):
    x: Optional[float] = Field(None, ge=0)
    y: Optional[float] = Field(None, ge=0)
    width: Optional[float] = Field(None, gt=0)
    height: Optional[float] = Field(None, gt=0)
    rotation: Optional[float] = Field(None, ge=-360, le=360)
    color: Optional[str] = Field(None, max_length=50)
    stroke_color: Optional[str] = Field(None, max_length=50)
    stroke_width: Optional[float] = Field(None, gt=0)
    is_visible: Optional[bool] = None

class BoatPositionResponse(BoatPositionBase):
    id: int
    map_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True

# backend/app/schemas/map.py
# backend/app/schemas/map.py
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime

class MapBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    image_width: int = Field(default=794, gt=0)
    image_height: int = Field(default=1123, gt=0)
    is_active: bool = True

class MapCreate(MapBase):
    image_path: str = Field(..., min_length=1)
    
    @validator('image_path')
    def validate_image_path(cls, v):
        allowed_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp']
        if not any(v.lower().endswith(ext) for ext in allowed_extensions):
            raise ValueError('Image must be a valid image file (.jpg, .jpeg, .png, .gif, .bmp)')
        return v

class MapUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = None
    image_path: Optional[str] = None
    image_width: Optional[int] = Field(None, gt=0)
    image_height: Optional[int] = Field(None, gt=0)
    is_active: Optional[bool] = None

class MapResponse(MapBase):
    id: int
    image_path: str
    created_at: datetime
    updated_at: Optional[datetime] = None
    boat_count: Optional[int] = 0  # Computed field
    
    class Config:
        from_attributes = True



# backend/app/schemas/boat_listing.py
# backend/app/schemas/boat_listing.py
from pydantic import BaseModel, Field, validator
from typing import Optional
from datetime import datetime

class BoatListingBase(BaseModel):
    name: Optional[str] = Field(None, max_length=100)
    customer_name: str = Field(..., min_length=1, max_length=100)
    size: Optional[str] = Field(None, max_length=50)
    make_model: Optional[str] = Field(None, max_length=100)
    vehicle_type: Optional[str] = Field(None, max_length=50)
    section: Optional[str] = Field(None, max_length=10)
    notes: Optional[str] = None

class BoatListingCreate(BoatListingBase):
    index: int = Field(..., gt=0)
    
    @validator('index')
    def validate_index(cls, v):
        if v <= 0:
            raise ValueError('Index must be a positive integer')
        return v
    
    @validator('section')
    def validate_section(cls, v):
        if v is not None:
            allowed_sections = ['A', 'B', 'C', 'D', 'E', 'F']
            if v.upper() not in allowed_sections:
                raise ValueError(f'Section must be one of: {", ".join(allowed_sections)}')
            return v.upper()
        return v

class BoatListingUpdate(BaseModel):
    index: Optional[int] = Field(None, gt=0)
    name: Optional[str] = Field(None, max_length=100)
    customer_name: Optional[str] = Field(None, min_length=1, max_length=100)
    size: Optional[str] = Field(None, max_length=50)
    make_model: Optional[str] = Field(None, max_length=100)
    vehicle_type: Optional[str] = Field(None, max_length=50)
    section: Optional[str] = Field(None, max_length=10)
    notes: Optional[str] = None
    
    @validator('section')
    def validate_section(cls, v):
        if v is not None:
            allowed_sections = ['A', 'B', 'C', 'D', 'E', 'F']
            if v.upper() not in allowed_sections:
                raise ValueError(f'Section must be one of: {", ".join(allowed_sections)}')
            return v.upper()
        return v

class BoatListingResponse(BoatListingBase):
    id: int
    index: int
    is_mapped: bool
    position_id: Optional[int] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True



# backend/app/schemas/composite.py
# backend/app/schemas/composite.py
from pydantic import BaseModel
from typing import Optional, List
from .boat_listing import BoatListingResponse
from .boat_position import BoatPositionResponse
from .map import MapResponse

class BoatWithPosition(BaseModel):
    """Boat listing with its position data"""
    boat: Optional[BoatListingResponse] = None
    position: BoatPositionResponse

class MapWithBoats(BaseModel):
    """Map with all its boat positions"""
    map: MapResponse
    boats: List[BoatWithPosition] = []

# backend/app/api/deps.py
# backend/app/api/deps.py
from typing import Generator, Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from ..core.database import get_db
from ..core.security import verify_token
from ..models.user import User, UserRole
from ..services.auth import AuthService

security = HTTPBearer()

def get_current_user(
    db: Session = Depends(get_db),
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> User:
    """Get current authenticated user"""
    token = credentials.credentials
    email = verify_token(token)
    
    if email is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user = AuthService.get_user_by_email(db, email=email)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    
    return user

def get_current_admin_user(current_user: User = Depends(get_current_user)) -> User:
    """Require admin role"""
    if current_user.role != UserRole.ADMIN:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user



# backend/app/api/v1/auth.py
# backend/app/api/v1/auth.py
from datetime import timedelta
from typing import Any
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from ...core.database import get_db
from ...core.security import create_access_token
from ...core.config import settings
from ...schemas.user import UserCreate, UserResponse, Token
from ...services.auth import AuthService
from ..deps import get_current_admin_user

router = APIRouter()

@router.post("/login", response_model=Token)
def login_for_access_token(
    db: Session = Depends(get_db),
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Any:
    """OAuth2 compatible token login, get an access token for future requests"""
    user = AuthService.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    elif not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, 
            detail="Inactive user"
        )
    
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        subject=user.email, expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
    }

@router.post("/register", response_model=UserResponse)
def create_user(
    user_in: UserCreate,
    db: Session = Depends(get_db),
    current_admin: Any = Depends(get_current_admin_user)
) -> Any:
    """Create new user (admin only)"""
    user = AuthService.create_user(db, user_in)
    return user



# backend/app/api/v1/maps.py
# backend/app/api/v1/maps.py
from typing import Any, List
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from ...core.database import get_db
from ...schemas.map import MapCreate, MapUpdate, MapResponse
from ...schemas.composite import MapWithBoats, BoatWithPosition
from ...services.map import MapService
from ...services.boat import BoatService
from ..deps import get_current_user, get_current_admin_user

router = APIRouter()

@router.get("/", response_model=List[MapResponse])
def read_maps(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=100),
    active_only: bool = Query(True),
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Retrieve maps with pagination"""
    maps = MapService.get_maps(db, skip=skip, limit=limit, active_only=active_only)
    
    # Add boat count to each map
    for map_obj in maps:
        map_obj.boat_count = MapService.get_map_boat_count(db, map_obj.id)
    
    return maps

@router.post("/", response_model=MapResponse)
def create_map(
    map_in: MapCreate,
    db: Session = Depends(get_db),
    current_admin: Any = Depends(get_current_admin_user)
) -> Any:
    """Create new map (admin only)"""
    map_obj = MapService.create_map(db, map_in)
    map_obj.boat_count = 0
    return map_obj

@router.get("/{map_id}", response_model=MapWithBoats)
def read_map(
    map_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Get map with all boat positions"""
    map_obj = MapService.get_map_by_id(db, map_id)
    if map_obj is None:
        raise HTTPException(status_code=404, detail="Map not found")
    
    # Get all boats with positions for this map
    boats_with_positions = BoatService.get_boats_with_positions(db, map_id)
    
    # Format response
    boats = []
    for item in boats_with_positions:
        boat_with_pos = BoatWithPosition(
            boat=item["boat"] if item["boat"] else None,
            position=item["position"]
        )
        boats.append(boat_with_pos)
    
    map_obj.boat_count = len(boats)
    
    return MapWithBoats(
        map=map_obj,
        boats=boats
    )

@router.put("/{map_id}", response_model=MapResponse)
def update_map(
    map_id: int,
    map_update: MapUpdate,
    db: Session = Depends(get_db),
    current_admin: Any = Depends(get_current_admin_user)
) -> Any:
    """Update map (admin only)"""
    map_obj = MapService.update_map(db, map_id, map_update)
    map_obj.boat_count = MapService.get_map_boat_count(db, map_id)
    return map_obj

@router.delete("/{map_id}")
def delete_map(
    map_id: int,
    db: Session = Depends(get_db),
    current_admin: Any = Depends(get_current_admin_user)
) -> Any:
    """Delete map (admin only)"""
    MapService.delete_map(db, map_id)
    return {"message": "Map deleted successfully"}



# backend/app/api/v1/boats.py
# backend/app/api/v1/boats.py
from typing import Any, List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from ...core.database import get_db
from ...schemas.boat_listing import BoatListingCreate, BoatListingUpdate, BoatListingResponse
from ...services.boat import BoatService
from ..deps import get_current_user

router = APIRouter()

@router.get("/", response_model=List[BoatListingResponse])
def read_boats(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=100),
    search: Optional[str] = Query(None),
    mapped_only: Optional[bool] = Query(None),
    section: Optional[str] = Query(None),
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Retrieve boats with filtering and pagination"""
    boats = BoatService.get_boats(
        db, 
        skip=skip, 
        limit=limit, 
        search=search, 
        mapped_only=mapped_only,
        section=section
    )
    return boats

@router.post("/", response_model=BoatListingResponse)
def create_boat(
    boat_in: BoatListingCreate,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Create new boat listing"""
    boat = BoatService.create_boat(db, boat_in)
    return boat

@router.get("/{boat_id}", response_model=BoatListingResponse)
def read_boat(
    boat_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Get boat by ID"""
    boat = BoatService.get_boat_by_id(db, boat_id)
    if boat is None:
        raise HTTPException(status_code=404, detail="Boat not found")
    return boat

@router.get("/index/{index}", response_model=BoatListingResponse)
def read_boat_by_index(
    index: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Get boat by index"""
    boat = BoatService.get_boat_by_index(db, index)
    if boat is None:
        raise HTTPException(status_code=404, detail="Boat not found")
    return boat

@router.put("/{boat_id}", response_model=BoatListingResponse)
def update_boat(
    boat_id: int,
    boat_update: BoatListingUpdate,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Update boat listing"""
    boat = BoatService.update_boat(db, boat_id, boat_update)
    return boat

@router.delete("/{boat_id}")
def delete_boat(
    boat_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Delete boat listing"""
    BoatService.delete_boat(db, boat_id)
    return {"message": "Boat deleted successfully"}

@router.post("/{boat_id}/assign/{position_id}", response_model=BoatListingResponse)
def assign_boat_to_position(
    boat_id: int,
    position_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Assign boat to position on map"""
    boat = BoatService.assign_boat_to_position(db, boat_id, position_id)
    return boat

@router.post("/{boat_id}/unassign", response_model=BoatListingResponse)
def unassign_boat_from_position(
    boat_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Unassign boat from its current position"""
    boat = BoatService.unassign_boat_from_position(db, boat_id)
    return boat



# backend/app/api/v1/__init__.py
# backend/app/api/v1/__init__.py
from fastapi import APIRouter
from .auth import router as auth_router
from .maps import router as maps_router  
from .boats import router as boats_router
from .positions import router as positions_router

api_router = APIRouter()

api_router.include_router(auth_router, prefix="/auth", tags=["authentication"])
api_router.include_router(maps_router, prefix="/maps", tags=["maps"])
api_router.include_router(boats_router, prefix="/boats", tags=["boats"])
api_router.include_router(positions_router, prefix="/positions", tags=["positions"])



# backend/app/api/v1/positions.py
# backend/app/api/v1/positions.py
from typing import Any, List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from ...core.database import get_db
from ...schemas.boat_position import BoatPositionCreate, BoatPositionUpdate, BoatPositionResponse
from ...services.boat import BoatService
from ..deps import get_current_user

router = APIRouter()

@router.get("/map/{map_id}", response_model=List[BoatPositionResponse])
def read_positions_by_map(
    map_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Get all boat positions for a specific map"""
    positions = BoatService.get_positions_by_map(db, map_id)
    return positions

@router.post("/", response_model=BoatPositionResponse)
def create_position(
    position_in: BoatPositionCreate,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Create new boat position"""
    position = BoatService.create_position(db, position_in)
    return position

@router.get("/{position_id}", response_model=BoatPositionResponse)
def read_position(
    position_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Get position by ID"""
    position = BoatService.get_position_by_id(db, position_id)
    if position is None:
        raise HTTPException(status_code=404, detail="Position not found")
    return position

@router.put("/{position_id}", response_model=BoatPositionResponse)
def update_position(
    position_id: int,
    position_update: BoatPositionUpdate,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Update boat position"""
    position = BoatService.update_position(db, position_id, position_update)
    return position

@router.delete("/{position_id}")
def delete_position(
    position_id: int,
    db: Session = Depends(get_db),
    current_user: Any = Depends(get_current_user)
) -> Any:
    """Delete boat position"""
    BoatService.delete_position(db, position_id)
    return {"message": "Position deleted successfully"}



# backend/app/services/auth.py
# backend/app/services/auth.py
from typing import Optional
from sqlalchemy.orm import Session
from ..models.user import User
from ..schemas.user import UserCreate, UserUpdate
from ..core.security import get_password_hash, verify_password
from ..core.exceptions import NotFoundError, ValidationError

class AuthService:
    """Service layer for authentication and user management"""
    
    @staticmethod
    def get_user_by_email(db: Session, email: str) -> Optional[User]:
        """Get user by email address"""
        return db.query(User).filter(User.email == email).first()
    
    @staticmethod
    def get_user_by_id(db: Session, user_id: int) -> Optional[User]:
        """Get user by ID"""
        return db.query(User).filter(User.id == user_id).first()
    
    @staticmethod
    def authenticate_user(db: Session, email: str, password: str) -> Optional[User]:
        """Authenticate user with email and password"""
        user = AuthService.get_user_by_email(db, email)
        if not user:
            return None
        if not verify_password(password, user.hashed_password):
            return None
        return user
    
    @staticmethod
    def create_user(db: Session, user_create: UserCreate) -> User:
        """Create new user"""
        # Check if user already exists
        if AuthService.get_user_by_email(db, user_create.email):
            raise ValidationError("Email already registered")
        
        # Create user
        hashed_password = get_password_hash(user_create.password)
        db_user = User(
            email=user_create.email,
            hashed_password=hashed_password,
            full_name=user_create.full_name,
            role=user_create.role,
            is_active=user_create.is_active
        )
        
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        return db_user
    
    @staticmethod
    def update_user(db: Session, user_id: int, user_update: UserUpdate) -> User:
        """Update existing user"""
        db_user = AuthService.get_user_by_id(db, user_id)
        if not db_user:
            raise NotFoundError("User not found")
        
        # Check email uniqueness if being updated
        if user_update.email and user_update.email != db_user.email:
            existing_user = AuthService.get_user_by_email(db, user_update.email)
            if existing_user:
                raise ValidationError("Email already in use")
        
        # Update fields
        update_data = user_update.dict(exclude_unset=True)
        if "password" in update_data:
            update_data["hashed_password"] = get_password_hash(update_data.pop("password"))
        
        for field, value in update_data.items():
            setattr(db_user, field, value)
        
        db.commit()
        db.refresh(db_user)
        return db_user



# backend/app/services/__init__.py
# backend/app/services/__init__.py
from .auth import AuthService
from .boat import BoatService
from .map import MapService

__all__ = ["AuthService", "BoatService", "MapService"]



# backend/app/services/map.py
# backend/app/services/map.py
from typing import Optional, List
from sqlalchemy.orm import Session
from sqlalchemy import and_
from ..models.map import Map
from ..models.boat_position import BoatPosition
from ..schemas.map import MapCreate, MapUpdate
from ..core.exceptions import NotFoundError, ValidationError

class MapService:
    """Service layer for map management"""
    
    @staticmethod
    def get_map_by_id(db: Session, map_id: int) -> Optional[Map]:
        """Get map by ID"""
        return db.query(Map).filter(Map.id == map_id).first()
    
    @staticmethod
    def get_maps(
        db: Session, 
        skip: int = 0, 
        limit: int = 100, 
        active_only: bool = True
    ) -> List[Map]:
        """Get all maps with pagination"""
        query = db.query(Map)
        if active_only:
            query = query.filter(Map.is_active == True)
        return query.offset(skip).limit(limit).all()
    
    @staticmethod
    def create_map(db: Session, map_create: MapCreate) -> Map:
        """Create new map"""
        # Validate unique name for active maps
        existing_map = db.query(Map).filter(
            and_(Map.name == map_create.name, Map.is_active == True)
        ).first()
        if existing_map:
            raise ValidationError("Active map with this name already exists")
        
        db_map = Map(**map_create.dict())
        db.add(db_map)
        db.commit()
        db.refresh(db_map)
        return db_map
    
    @staticmethod
    def update_map(db: Session, map_id: int, map_update: MapUpdate) -> Map:
        """Update existing map"""
        db_map = MapService.get_map_by_id(db, map_id)
        if not db_map:
            raise NotFoundError("Map not found")
        
        # Validate unique name if being updated
        if map_update.name and map_update.name != db_map.name:
            existing_map = db.query(Map).filter(
                and_(Map.name == map_update.name, Map.is_active == True, Map.id != map_id)
            ).first()
            if existing_map:
                raise ValidationError("Active map with this name already exists")
        
        update_data = map_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_map, field, value)
        
        db.commit()
        db.refresh(db_map)
        return db_map
    
    @staticmethod
    def delete_map(db: Session, map_id: int) -> bool:
        """Soft delete map (set inactive)"""
        db_map = MapService.get_map_by_id(db, map_id)
        if not db_map:
            raise NotFoundError("Map not found")
        
        # Check if map has boat positions
        position_count = db.query(BoatPosition).filter(BoatPosition.map_id == map_id).count()
        if position_count > 0:
            # Soft delete - set inactive
            db_map.is_active = False
            db.commit()
        else:
            # Hard delete if no positions
            db.delete(db_map)
            db.commit()
        
        return True
    
    @staticmethod
    def get_map_boat_count(db: Session, map_id: int) -> int:
        """Get count of boat positions on map"""
        return db.query(BoatPosition).filter(
            BoatPosition.map_id == map_id
        ).count()



# backend/app/services/boat.py
# backend/app/services/boat.py
from typing import Optional, List, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import or_, and_
from ..models.boat_listing import BoatListing
from ..models.boat_position import BoatPosition
from ..schemas.boat_listing import BoatListingCreate, BoatListingUpdate
from ..schemas.boat_position import BoatPositionCreate, BoatPositionUpdate
from ..core.exceptions import NotFoundError, ValidationError, DuplicateError

class BoatService:
    """Service layer for boat management"""
    
    # Boat Listing methods
    @staticmethod
    def get_boat_by_id(db: Session, boat_id: int) -> Optional[BoatListing]:
        """Get boat listing by ID"""
        return db.query(BoatListing).filter(BoatListing.id == boat_id).first()
    
    @staticmethod
    def get_boat_by_index(db: Session, index: int) -> Optional[BoatListing]:
        """Get boat listing by index"""
        return db.query(BoatListing).filter(BoatListing.index == index).first()
    
    @staticmethod
    def get_boats(
        db: Session,
        skip: int = 0,
        limit: int = 100,
        search: Optional[str] = None,
        mapped_only: Optional[bool] = None,
        section: Optional[str] = None
    ) -> List[BoatListing]:
        """Get boat listings with filters and pagination"""
        query = db.query(BoatListing)
        
        # Search filter
        if search:
            search_filter = or_(
                BoatListing.name.ilike(f"%{search}%"),
                BoatListing.customer_name.ilike(f"%{search}%"),
                BoatListing.make_model.ilike(f"%{search}%"),
                BoatListing.vehicle_type.ilike(f"%{search}%"),
                BoatListing.size.ilike(f"%{search}%"),
                BoatListing.notes.ilike(f"%{search}%")
            )
            query = query.filter(search_filter)
        
        # Mapped filter
        if mapped_only is not None:
            query = query.filter(BoatListing.is_mapped == mapped_only)
        
        # Section filter
        if section:
            query = query.filter(BoatListing.section == section.upper())
        
        return query.order_by(BoatListing.index).offset(skip).limit(limit).all()
    
    @staticmethod
    def create_boat(db: Session, boat_create: BoatListingCreate) -> BoatListing:
        """Create new boat listing"""
        # Check if index already exists
        if BoatService.get_boat_by_index(db, boat_create.index):
            raise DuplicateError(f"Boat with index {boat_create.index} already exists")
        
        db_boat = BoatListing(**boat_create.dict())
        db.add(db_boat)
        db.commit()
        db.refresh(db_boat)
        return db_boat
    
    @staticmethod
    def update_boat(db: Session, boat_id: int, boat_update: BoatListingUpdate) -> BoatListing:
        """Update existing boat listing"""
        db_boat = BoatService.get_boat_by_id(db, boat_id)
        if not db_boat:
            raise NotFoundError("Boat not found")
        
        # Check index uniqueness if being updated
        if boat_update.index and boat_update.index != db_boat.index:
            existing_boat = BoatService.get_boat_by_index(db, boat_update.index)
            if existing_boat:
                raise DuplicateError(f"Boat with index {boat_update.index} already exists")
        
        update_data = boat_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_boat, field, value)
        
        db.commit()
        db.refresh(db_boat)
        return db_boat
    
    @staticmethod
    def delete_boat(db: Session, boat_id: int) -> bool:
        """Delete boat listing and its position"""
        db_boat = BoatService.get_boat_by_id(db, boat_id)
        if not db_boat:
            raise NotFoundError("Boat not found")
        
        # Delete associated position first (cascade should handle this)
        if db_boat.position:
            db.delete(db_boat.position)
        
        db.delete(db_boat)
        db.commit()
        return True
    
    # Boat Position methods
    @staticmethod
    def get_position_by_id(db: Session, position_id: int) -> Optional[BoatPosition]:
        """Get boat position by ID"""
        return db.query(BoatPosition).filter(BoatPosition.id == position_id).first()
    
    @staticmethod
    def get_positions_by_map(db: Session, map_id: int) -> List[BoatPosition]:
        """Get all boat positions for a specific map"""
        return db.query(BoatPosition).filter(BoatPosition.map_id == map_id).all()
    
    @staticmethod
    def create_position(db: Session, position_create: BoatPositionCreate) -> BoatPosition:
        """Create new boat position"""
        db_position = BoatPosition(**position_create.dict())
        db.add(db_position)
        db.commit()
        db.refresh(db_position)
        return db_position
    
    @staticmethod
    def update_position(db: Session, position_id: int, position_update: BoatPositionUpdate) -> BoatPosition:
        """Update existing boat position"""
        db_position = BoatService.get_position_by_id(db, position_id)
        if not db_position:
            raise NotFoundError("Position not found")
        
        update_data = position_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_position, field, value)
        
        db.commit()
        db.refresh(db_position)
        return db_position
    
    @staticmethod
    def delete_position(db: Session, position_id: int) -> bool:
        """Delete boat position"""
        db_position = BoatService.get_position_by_id(db, position_id)
        if not db_position:
            raise NotFoundError("Position not found")
        
        # Update associated boat listing
        if db_position.boat_listing:
            db_position.boat_listing.is_mapped = False
            db_position.boat_listing.position_id = None
        
        db.delete(db_position)
        db.commit()
        return True
    
    @staticmethod
    def assign_boat_to_position(db: Session, boat_id: int, position_id: int) -> BoatListing:
        """Assign a boat listing to a position"""
        db_boat = BoatService.get_boat_by_id(db, boat_id)
        if not db_boat:
            raise NotFoundError("Boat not found")
        
        db_position = BoatService.get_position_by_id(db, position_id)
        if not db_position:
            raise NotFoundError("Position not found")
        
        # Check if position is already assigned
        if db_position.boat_listing:
            raise ValidationError("Position already assigned to another boat")
        
        # Unassign boat from previous position if any
        if db_boat.position:
            db_boat.position.boat_listing = None
        
        # Assign boat to new position
        db_boat.position_id = position_id
        db_boat.is_mapped = True
        
        db.commit()
        db.refresh(db_boat)
        return db_boat
    
    @staticmethod
    def unassign_boat_from_position(db: Session, boat_id: int) -> BoatListing:
        """Unassign a boat from its current position"""
        db_boat = BoatService.get_boat_by_id(db, boat_id)
        if not db_boat:
            raise NotFoundError("Boat not found")
        
        if not db_boat.position:
            raise ValidationError("Boat is not currently assigned to any position")
        
        db_boat.position_id = None
        db_boat.is_mapped = False
        
        db.commit()
        db.refresh(db_boat)
        return db_boat
    
    @staticmethod
    def get_boats_with_positions(db: Session, map_id: int) -> List[Dict[str, Any]]:
        """Get all boats with their positions for a specific map"""
        # Get all positions for the map
        positions = BoatService.get_positions_by_map(db, map_id)
        
        result = []
        for position in positions:
            boat_data = {
                "position": position,
                "boat": position.boat_listing if position.boat_listing else None
            }
            result.append(boat_data)
        
        return result

# backend/tests/test_models/test_boat_position.py
# backend/tests/test_models/test_boat_position.py
import pytest
from sqlalchemy.orm import Session
from app.models.boat_position import BoatPosition
from app.models.map import Map

def test_create_boat_position(db: Session):
    """Test creating a boat position"""
    map_obj = Map(name="Test Map", image_path="test.jpg")
    db.add(map_obj)
    db.commit()
    
    position = BoatPosition(
        map_id=map_obj.id,
        x=100.5,
        y=200.5,
        width=150.0,
        height=75.0,
        rotation=45.0,
        color="blue"
    )
    db.add(position)
    db.commit()
    db.refresh(position)
    
    assert position.id is not None
    assert position.x == 100.5
    assert position.y == 200.5
    assert position.rotation == 45.0
    assert position.color == "blue"

def test_boat_position_defaults(db: Session):
    """Test default values for boat position"""
    map_obj = Map(name="Test Map", image_path="test.jpg")
    db.add(map_obj)
    db.commit()
    
    position = BoatPosition(map_id=map_obj.id)
    db.add(position)
    db.commit()
    db.refresh(position)
    
    assert position.x == 200.0
    assert position.y == 200.0
    assert position.width == 100.0
    assert position.height == 50.0
    assert position.rotation == 0.0
    assert position.color == "blue"



# backend/tests/test_models/test_boat_listing.py
# backend/tests/test_models/test_boat_listing.py
import pytest
from sqlalchemy.orm import Session
from app.models.boat_listing import BoatListing
from app.models.boat_position import BoatPosition
from app.models.map import Map

def test_create_boat_listing(db: Session):
    """Test creating a boat listing"""
    boat = BoatListing(
        index=1,
        name="Test Boat",
        customer_name="John Doe",
        size="30 ft",
        make_model="Sea Ray Sundancer",
        vehicle_type="boat",
        section="A",
        notes="Test notes"
    )
    db.add(boat)
    db.commit()
    db.refresh(boat)
    
    assert boat.id is not None
    assert boat.index == 1
    assert boat.name == "Test Boat"
    assert boat.is_mapped == False

def test_boat_listing_unique_index(db: Session):
    """Test that boat index must be unique"""
    boat1 = BoatListing(index=1, customer_name="John Doe")
    boat2 = BoatListing(index=1, customer_name="Jane Doe")
    
    db.add(boat1)
    db.commit()
    
    db.add(boat2)
    with pytest.raises(Exception):  # Should raise IntegrityError
        db.commit()

def test_boat_position_relationship(db: Session):
    """Test boat listing to position relationship"""
    # Create map first
    map_obj = Map(name="Test Map", image_path="test.jpg")
    db.add(map_obj)
    db.commit()
    
    # Create position
    position = BoatPosition(map_id=map_obj.id, x=100, y=200)
    db.add(position)
    db.commit()
    
    # Create boat and link to position
    boat = BoatListing(
        index=1,
        customer_name="John Doe",
        position_id=position.id,
        is_mapped=True
    )
    db.add(boat)
    db.commit()
    db.refresh(boat)
    
    assert boat.position is not None
    assert boat.position.id == position.id
    assert boat.is_mapped == True



# backend/tests/test_services/test_boat_service.py
# backend/tests/test_services/test_boat_service.py
import pytest
from sqlalchemy.orm import Session
from app.services.boat import BoatService
from app.schemas.boat_listing import BoatListingCreate, BoatListingUpdate
from app.schemas.boat_position import BoatPositionCreate
from app.models.map import Map
from app.core.exceptions import NotFoundError, DuplicateError, ValidationError

def test_create_boat_service(db: Session):
    """Test creating boat via service"""
    boat_create = BoatListingCreate(
        index=1,
        customer_name="John Doe",
        size="30 ft"
    )
    boat = BoatService.create_boat(db, boat_create)
    
    assert boat.id is not None
    assert boat.index == 1
    assert boat.customer_name == "John Doe"

def test_create_duplicate_boat_service(db: Session):
    """Test creating duplicate boat raises error"""
    boat_create = BoatListingCreate(index=1, customer_name="John Doe")
    
    BoatService.create_boat(db, boat_create)
    
    with pytest.raises(DuplicateError):
        BoatService.create_boat(db, boat_create)

def test_get_boats_with_search(db: Session):
    """Test getting boats with search filter"""
    # Create test boats
    boat1 = BoatListingCreate(
        index=1,
        customer_name="John Smith",
        make_model="Sea Ray"
    )
    boat2 = BoatListingCreate(
        index=2,
        customer_name="Jane Doe",
        make_model="Boston Whaler"
    )
    
    BoatService.create_boat(db, boat1)
    BoatService.create_boat(db, boat2)
    
    # Search by customer name
    results = BoatService.get_boats(db, search="John")
    assert len(results) == 1
    assert results[0].customer_name == "John Smith"
    
    # Search by make/model
    results = BoatService.get_boats(db, search="Boston")
    assert len(results) == 1
    assert results[0].make_model == "Boston Whaler"

def test_assign_boat_to_position(db: Session):
    """Test assigning boat to position"""
    # Create map
    map_obj = Map(name="Test Map", image_path="test.jpg")
    db.add(map_obj)
    db.commit()
    
    # Create boat
    boat_create = BoatListingCreate(index=1, customer_name="John Doe")
    boat = BoatService.create_boat(db, boat_create)
    
    # Create position
    position_create = BoatPositionCreate(map_id=map_obj.id, x=100, y=200)
    position = BoatService.create_position(db, position_create)
    
    # Assign boat to position
    updated_boat = BoatService.assign_boat_to_position(db, boat.id, position.id)
    
    assert updated_boat.is_mapped == True
    assert updated_boat.position_id == position.id

def test_assign_boat_to_occupied_position(db: Session):
    """Test assigning boat to already occupied position fails"""
    # Create map
    map_obj = Map(name="Test Map", image_path="test.jpg")
    db.add(map_obj)
    db.commit()
    
    # Create two boats
    boat1 = BoatService.create_boat(db, BoatListingCreate(index=1, customer_name="John Doe"))
    boat2 = BoatService.create_boat(db, BoatListingCreate(index=2, customer_name="Jane Doe"))
    
    # Create position
    position = BoatService.create_position(db, BoatPositionCreate(map_id=map_obj.id))
    
    # Assign first boat
    BoatService.assign_boat_to_position(db, boat1.id, position.id)
    
    # Try to assign second boat to same position
    with pytest.raises(ValidationError):
        BoatService.assign_boat_to_position(db, boat2.id, position.id)



# backend/tests/test_api/test_auth.py
# backend/tests/test_api/test_auth.py
from fastapi.testclient import TestClient

def test_login_success(client: TestClient, admin_user):
    """Test successful login"""
    response = client.post(
        "/api/v1/auth/login",
        data={"username": admin_user.email, "password": "AdminPass123!"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

def test_login_wrong_password(client: TestClient, admin_user):
    """Test login with wrong password"""
    response = client.post(
        "/api/v1/auth/login",
        data={"username": admin_user.email, "password": "wrongpassword"}
    )
    assert response.status_code == 401
    assert response.json()["detail"] == "Incorrect email or password"

def test_login_nonexistent_user(client: TestClient):
    """Test login with nonexistent user"""
    response = client.post(
        "/api/v1/auth/login",
        data={"username": "nonexistent@example.com", "password": "password"}
    )
    assert response.status_code == 401

def test_create_user_admin(client: TestClient, admin_headers):
    """Test creating user as admin"""
    user_data = {
        "email": "newuser@pier11marina.com",
        "full_name": "New User",
        "password": "NewPass123!",
        "role": "staff"
    }
    response = client.post(
        "/api/v1/auth/register",
        json=user_data,
        headers=admin_headers
    )
    assert response.status_code == 200
    data = response.json()
    assert data["email"] == user_data["email"]
    assert data["role"] == "staff"

def test_create_user_staff_forbidden(client: TestClient, staff_headers):
    """Test that staff cannot create users"""
    user_data = {
        "email": "newuser@pier11marina.com",
        "full_name": "New User",
        "password": "NewPass123!",
        "role": "staff"
    }
    response = client.post(
        "/api/v1/auth/register",
        json=user_data,
        headers=staff_headers
    )
    assert response.status_code == 403



# backend/tests/test_api/test_boats.py
# backend/tests/test_api/test_boats.py
from fastapi.testclient import TestClient

def test_create_boat(client: TestClient, staff_headers):
    """Test creating a boat listing"""
    boat_data = {
        "index": 1,
        "name": "Test Boat",
        "customer_name": "John Doe",
        "size": "30 ft",
        "make_model": "Sea Ray Sundancer",
        "vehicle_type": "boat",
        "section": "A",
        "notes": "Test notes"
    }
    response = client.post(
        "/api/v1/boats/",
        json=boat_data,
        headers=staff_headers
    )
    assert response.status_code == 200
    data = response.json()
    assert data["index"] == 1
    assert data["name"] == "Test Boat"
    assert data["is_mapped"] == False

def test_create_duplicate_index(client: TestClient, staff_headers):
    """Test creating boat with duplicate index fails"""
    boat_data = {
        "index": 1,
        "customer_name": "John Doe"
    }
    
    # Create first boat
    response = client.post("/api/v1/boats/", json=boat_data, headers=staff_headers)
    assert response.status_code == 200
    
    # Try to create duplicate
    response = client.post("/api/v1/boats/", json=boat_data, headers=staff_headers)
    assert response.status_code == 409

def test_get_boats(client: TestClient, staff_headers):
    """Test getting boat listings"""
    # Create test boats
    for i in range(5):
        boat_data = {
            "index": i + 1,
            "customer_name": f"Customer {i + 1}",
            "size": f"{20 + i * 5} ft"
        }
        client.post("/api/v1/boats/", json=boat_data, headers=staff_headers)
    
    response = client.get("/api/v1/boats/", headers=staff_headers)
    assert response.status_code == 200
    data = response.json()
    assert len(data) == 5

def test_search_boats(client: TestClient, staff_headers):
    """Test searching boat listings"""
    # Create test boats
    boat1_data = {
        "index": 1,
        "customer_name": "John Smith",
        "make_model": "Sea Ray"
    }
    boat2_data = {
        "index": 2,
        "customer_name": "Jane Doe",
        "make_model": "Boston Whaler"
    }
    
    client.post("/api/v1/boats/", json=boat1_data, headers=staff_headers)
    client.post("/api/v1/boats/", json=boat2_data, headers=staff_headers)
    
    # Search by customer name
    response = client.get("/api/v1/boats/?search=John", headers=staff_headers)
    assert response.status_code == 200
    data = response.json()
    assert len(data) == 1
    assert data[0]["customer_name"] == "John Smith"

def test_update_boat(client: TestClient, staff_headers):
    """Test updating boat listing"""
    # Create boat
    boat_data = {
        "index": 1,
        "customer_name": "John Doe",
        "size": "30 ft"
    }
    response = client.post("/api/v1/boats/", json=boat_data, headers=staff_headers)
    boat_id = response.json()["id"]
    
    # Update boat
    update_data = {
        "size": "35 ft",
        "notes": "Updated notes"
    }
    response = client.put(f"/api/v1/boats/{boat_id}", json=update_data, headers=staff_headers)
    assert response.status_code == 200
    data = response.json()
    assert data["size"] == "35 ft"
    assert data["notes"] == "Updated notes"

def test_delete_boat(client: TestClient, staff_headers):
    """Test deleting boat listing"""
    # Create boat
    boat_data = {
        "index": 1,
        "customer_name": "John Doe"
    }
    response = client.post("/api/v1/boats/", json=boat_data, headers=staff_headers)
    boat_id = response.json()["id"]
    
    # Delete boat
    response = client.delete(f"/api/v1/boats/{boat_id}", headers=staff_headers)
    assert response.status_code == 200
    
    # Verify deletion
    response = client.get(f"/api/v1/boats/{boat_id}", headers=staff_headers)
    assert response.status_code == 404



# backend/alembic/script.py.mako
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}


# backend/alembic/env.py
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = None

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


# backend/alembic/README
Generic single-database configuration.

# scripts/create_admin.py
#!/usr/bin/env python3
"""
Create initial admin user for Pier 11 Marina Interactive Map

This script creates the first admin user needed to bootstrap the authentication system.
Run this after setting up the database and running migrations.

Usage:
    python scripts/create_admin.py                    # Use default credentials
    python scripts/create_admin.py --interactive     # Custom credentials
    python scripts/create_admin.py --help           # Show help
"""

import sys
import os
import argparse
import getpass
from pathlib import Path

# Add backend to Python path
script_dir = Path(__file__).parent
backend_dir = script_dir.parent / "backend"
sys.path.insert(0, str(backend_dir))

try:
    from app.core.database import SessionLocal
    from app.models.user import User, UserRole
    from app.core.security import get_password_hash
    from app.services.auth import AuthService
except ImportError as e:
    print(f"Error importing backend modules: {e}")
    print("Make sure you're running this from the project root directory")
    print("and that you've installed the backend dependencies:")
    print("  cd backend && pip install -r requirements.txt")
    sys.exit(1)


def check_database_connection():
    """Test database connection before proceeding"""
    try:
        from sqlalchemy import text
        db = SessionLocal()
        db.execute(text("SELECT 1"))
        db.close()
        return True
    except Exception as e:
        print(f"Database connection failed: {e}")
        print("\nMake sure:")
        print("1. PostgreSQL is running: brew services start postgresql@14")
        print("2. Database exists: createdb pier11_marina")
        print("3. User has access: GRANT ALL PRIVILEGES ON DATABASE pier11_marina TO pier11;")
        print("4. Migrations are applied: alembic upgrade head")
        return False


def validate_email(email):
    """Basic email validation"""
    import re
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None


def validate_password(password):
    """Password strength validation"""
    if len(password) < 8:
        return False, "Password must be at least 8 characters long"
    if not any(c.isdigit() for c in password):
        return False, "Password must contain at least one number"
    if not any(c.islower() for c in password):
        return False, "Password must contain at least one lowercase letter"
    if not any(c.isupper() for c in password):
        return False, "Password must contain at least one uppercase letter"
    return True, "Password is valid"


def create_admin_user(email, password, full_name, interactive=False):
    """Create admin user with given credentials"""
    
    if not check_database_connection():
        return False
    
    db = SessionLocal()
    try:
        # Check if any users exist
        user_count = db.query(User).count()
        if user_count > 0:
            existing_admin = db.query(User).filter(
                User.role == UserRole.ADMIN
            ).first()
            
            if existing_admin:
                print(f"Admin user already exists: {existing_admin.email}")
                if not interactive:
                    print("Use --interactive flag to create additional admin users")
                    return True
        
        # Check if this specific email exists
        existing_user = db.query(User).filter(User.email == email).first()
        if existing_user:
            print(f"User with email {email} already exists")
            return False
        
        # Validate inputs
        if not validate_email(email):
            print(f"Invalid email format: {email}")
            return False
        
        is_valid, message = validate_password(password)
        if not is_valid:
            print(f"Password validation failed: {message}")
            return False
        
        # Create admin user
        admin_user = User(
            email=email,
            hashed_password=get_password_hash(password),
            full_name=full_name,
            role=UserRole.ADMIN,
            is_active=True
        )
        
        db.add(admin_user)
        db.commit()
        
        print(f"✅ Admin user created successfully!")
        print(f"   Email: {email}")
        print(f"   Name: {full_name}")
        print(f"   Role: admin")
        print(f"\nYou can now:")
        print(f"1. Start the server: uvicorn app.main:app --reload")
        print(f"2. Visit API docs: http://localhost:8000/docs")
        print(f"3. Click 'Authorize' and login with these credentials")
        
        if password == "admin123":
            print(f"\n⚠️  SECURITY WARNING: Change the default password after first login!")
        
        return True
        
    except Exception as e:
        db.rollback()
        print(f"Error creating admin user: {e}")
        return False
    finally:
        db.close()


def interactive_setup():
    """Interactive admin user creation"""
    print("🔧 Interactive Admin User Setup")
    print("=" * 40)
    
    while True:
        email = input("Admin email: ").strip()
        if validate_email(email):
            break
        print("Invalid email format. Please try again.")
    
    full_name = input("Full name: ").strip()
    if not full_name:
        full_name = "Admin User"
    
    while True:
        password = getpass.getpass("Password: ")
        password_confirm = getpass.getpass("Confirm password: ")
        
        if password != password_confirm:
            print("Passwords don't match. Please try again.")
            continue
        
        is_valid, message = validate_password(password)
        if is_valid:
            break
        print(f"Password requirements not met: {message}")
    
    return create_admin_user(email, password, full_name, interactive=True)


def default_setup():
    """Create admin user with default credentials"""
    print("🔧 Creating default admin user...")
    print("=" * 40)
    
    default_email = "admin@pier11marina.com"
    default_password = "Admin123"
    default_name = "Admin User"
    
    print(f"Email: {default_email}")
    print(f"Name: {default_name}")
    print(f"Password: {default_password}")
    print()
    
    print("Attempting to create admin user...")
    success = create_admin_user(default_email, default_password, default_name)
    
    if success:
        print("✅ Default admin user creation completed successfully!")
    else:
        print("❌ Default admin user creation failed!")
    
    return success


def show_manual_instructions():
    """Show manual SQL instructions as fallback"""
    print("\n📝 Manual Setup Instructions")
    print("=" * 40)
    print("If the script fails, you can create the admin user manually:")
    print()
    print("1. Connect to the database:")
    print("   psql -U pier11 -d pier11_marina")
    print()
    print("2. Insert admin user (replace the hash with a real one):")
    print("   INSERT INTO users (email, hashed_password, full_name, role, is_active, created_at)")
    print("   VALUES (")
    print("     'admin@pier11marina.com',")
    print("     '$2b$12$placeholder_hash_replace_this',")
    print("     'Admin User',")
    print("     'admin',")
    print("     true,")
    print("     NOW()")
    print("   );")
    print()
    print("3. Generate password hash in Python:")
    print("   from app.core.security import get_password_hash")
    print("   print(get_password_hash('your_password'))")


def run_comprehensive_tests():
    """Run comprehensive tests of all script functionality"""
    print("🧪 Running Comprehensive Tests")
    print("=" * 50)
    
    tests_passed = 0
    tests_failed = 0
    
    def test_case(name, test_func, *args, **kwargs):
        nonlocal tests_passed, tests_failed
        print(f"\n📋 Testing: {name}")
        try:
            result = test_func(*args, **kwargs)
            if result:
                print(f"   ✅ PASS")
                tests_passed += 1
            else:
                print(f"   ❌ FAIL")
                tests_failed += 1
        except Exception as e:
            print(f"   ❌ ERROR: {e}")
            tests_failed += 1
    
    # Test 1: Database connection
    test_case("Database Connection", check_database_connection)
    
    # Test 2: Email validation
    test_case("Valid Email", lambda: validate_email("test@example.com"))
    test_case("Invalid Email (no @)", lambda: not validate_email("invalid-email"))
    test_case("Invalid Email (no domain)", lambda: not validate_email("test@"))
    test_case("Invalid Email (no TLD)", lambda: not validate_email("test@domain"))
    
    # Test 3: Password validation
    def test_password_validation():
        valid_cases = [
            "Password123",
            "Complex1Pass",
            "MySecure123"
        ]
        invalid_cases = [
            "short",           # Too short
            "nouppercase123",  # No uppercase
            "NOLOWERCASE123",  # No lowercase
            "NoNumbers",       # No numbers
            "123456789"        # No letters
        ]
        
        for pwd in valid_cases:
            is_valid, _ = validate_password(pwd)
            if not is_valid:
                return False
        
        for pwd in invalid_cases:
            is_valid, _ = validate_password(pwd)
            if is_valid:
                return False
        
        return True
    
    test_case("Password Validation Logic", test_password_validation)
    
    # Test 4: Database user operations (read-only checks)
    def test_user_queries():
        try:
            db = SessionLocal()
            # Test basic query operations without modifying data
            user_count = db.query(User).count()
            admin_count = db.query(User).filter(User.role == UserRole.ADMIN).count()
            
            # Test that we can query user by email (should return None for non-existent)
            test_user = db.query(User).filter(User.email == "nonexistent@test.com").first()
            
            db.close()
            return True
        except Exception as e:
            print(f"      Database query error: {e}")
            return False
    
    test_case("Database User Queries", test_user_queries)
    
    # Test 5: Password hashing functionality
    def test_password_hashing():
        try:
            test_password = "TestPassword123"
            hashed = get_password_hash(test_password)
            
            # Check that hash is generated and is different from original
            if not hashed or hashed == test_password:
                return False
            
            # Check that hash starts with bcrypt prefix
            if not hashed.startswith("$2b$"):
                return False
            
            return True
        except Exception as e:
            print(f"      Password hashing error: {e}")
            return False
    
    test_case("Password Hashing", test_password_hashing)
    
    # Test 6: User enumeration (check existing users safely)
    def test_existing_users():
        try:
            db = SessionLocal()
            existing_users = db.query(User).all()
            
            print(f"      Found {len(existing_users)} existing users")
            for user in existing_users[:3]:  # Show first 3 users only
                print(f"      - {user.email} ({user.role.value})")
            
            if len(existing_users) > 3:
                print(f"      ... and {len(existing_users) - 3} more")
            
            db.close()
            return True
        except Exception as e:
            print(f"      User enumeration error: {e}")
            return False
    
    test_case("Existing Users Check", test_existing_users)
    
    # Test 7: Import verification
    def test_imports():
        try:
            # Test that all required modules can be imported
            from app.models.user import UserRole
            from app.core.security import get_password_hash
            from app.services.auth import AuthService
            
            # Test enum values
            if UserRole.ADMIN.value != "admin":
                return False
            if UserRole.STAFF.value != "staff":
                return False
            
            return True
        except Exception as e:
            print(f"      Import error: {e}")
            return False
    
    test_case("Module Imports", test_imports)
    
    # Test 8: Dry-run user creation (validation only)
    def test_dry_run_creation():
        try:
            # Test all the validation steps without actually creating a user
            test_email = "dryrun@test.com"
            test_password = "DryRun123"
            test_name = "Dry Run User"
            
            # Email validation
            if not validate_email(test_email):
                return False
            
            # Password validation
            is_valid, _ = validate_password(test_password)
            if not is_valid:
                return False
            
            # Password hashing
            hashed = get_password_hash(test_password)
            if not hashed:
                return False
            
            # Database connection check
            db = SessionLocal()
            existing = db.query(User).filter(User.email == test_email).first()
            db.close()
            
            # Should not exist (we're not creating it)
            return existing is None
            
        except Exception as e:
            print(f"      Dry run error: {e}")
            return False
    
    test_case("Dry Run User Creation", test_dry_run_creation)
    
    # Summary
    print(f"\n📊 Test Results Summary")
    print("=" * 30)
    print(f"Tests passed: {tests_passed}")
    print(f"Tests failed: {tests_failed}")
    print(f"Total tests:  {tests_passed + tests_failed}")
    
    if tests_failed == 0:
        print(f"\n🎉 All tests passed! The admin creation system is working correctly.")
        return True
    else:
        print(f"\n⚠️  {tests_failed} tests failed. Check the errors above.")
        print("Common issues:")
        print("- Database not running or not accessible")
        print("- Missing Python dependencies")
        print("- Database schema not migrated")
        print("- Permission issues")
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Create initial admin user for Pier 11 Marina",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument(
        "--interactive", "-i",
        action="store_true",
        help="Interactive setup with custom credentials"
    )
    parser.add_argument(
        "--manual",
        action="store_true", 
        help="Show manual setup instructions"
    )
    parser.add_argument(
        "--test",
        action="store_true",
        help="Run comprehensive tests of all script functionality"
    )
    
    args = parser.parse_args()
    
    print("🚢 Pier 11 Marina - Admin User Setup")
    print("=" * 50)
    
    if args.test:
        success = run_comprehensive_tests()
        if not success:
            sys.exit(1)
        return
    
    if args.manual:
        show_manual_instructions()
        return
    
    if args.interactive:
        success = interactive_setup()
    else:
        success = default_setup()
    
    if not success:
        print("\n❌ Admin user creation failed")
        show_manual_instructions()
        sys.exit(1)
    
    print("\n🎉 Setup complete! Your admin user is ready.")


if __name__ == "__main__":
    print("DEBUG: Script starting...")
    try:
        main()
        print("DEBUG: Script completed successfully")
    except Exception as e:
        print(f"DEBUG: Script failed with exception: {type(e).__name__}: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

